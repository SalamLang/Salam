(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
    get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
  }) : x)(function(x) {
    if (typeof require !== "undefined") return require.apply(this, arguments);
    throw Error('Dynamic require of "' + x + '" is not supported');
  });
  var __commonJS = (cb, mod) => function __require2() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
    mod
  ));

  // phase/generator/node_modules/sync-fetch/browser.js
  var require_browser = __commonJS({
    "phase/generator/node_modules/sync-fetch/browser.js"(exports, module) {
      var textEncoder = new TextEncoder();
      var textDecoder = new TextDecoder();
      function syncFetch(...args) {
        const request = new syncFetch.Request(...args);
        const xhr = new XMLHttpRequest();
        xhr.withCredentials = request.credentials === "include";
        xhr.timeout = request[INTERNALS].timeout;
        xhr.open(request.method, request.url, false);
        let useBinaryEncoding = false;
        try {
          xhr.responseType = "arraybuffer";
        } catch (e) {
          xhr.overrideMimeType("text/plain; charset=x-user-defined");
          useBinaryEncoding = true;
        }
        for (const header of request.headers) {
          xhr.setRequestHeader(...header);
        }
        xhr.send(request[INTERNALS].body || null);
        let headers = xhr.getAllResponseHeaders();
        headers = headers && headers.split("\r\n").filter(Boolean).map((header) => header.split(": ", 2));
        let body = xhr.response;
        if (useBinaryEncoding) {
          const buffer = new Uint8Array(body.length);
          for (let i = 0; i < body.length; i++) {
            buffer[i] = body.charCodeAt(i) & 255;
          }
          body = buffer;
        }
        const response = new syncFetch.Response(body, {
          headers,
          status: xhr.status,
          statusText: xhr.statusText
        });
        response[INTERNALS].url = xhr.responseURL;
        response[INTERNALS].redirected = xhr.responseURL !== request.url;
        return response;
      }
      var INTERNALS = Symbol("SyncFetch Internals");
      var REQ_UNSUPPORTED = ["mode", "cache", "redirect", "referrer", "integrity"];
      var HTTP_STATUS = {
        100: "Continue",
        101: "Switching Protocols",
        200: "OK",
        201: "Created",
        202: "Accepted",
        203: "Non-Authoritative Information",
        204: "No Content",
        205: "Reset Content",
        206: "Partial Content",
        300: "Multiple Choices",
        301: "Moved Permanently",
        302: "Found",
        303: "See Other",
        304: "Not Modified",
        305: "Use Proxy",
        307: "Temporary Redirect",
        400: "Bad Request",
        401: "Unauthorized",
        402: "Payment Required",
        403: "Forbidden",
        404: "Not Found",
        405: "Method Not Allowed",
        406: "Not Acceptable",
        407: "Proxy Authentication Required",
        408: "Request Timeout",
        409: "Conflict",
        410: "Gone",
        411: "Length Required",
        412: "Precondition Failed",
        413: "Payload Too Large",
        414: "URI Too Long",
        415: "Unsupported Media Type",
        416: "Range Not Satisfiable",
        417: "Expectation Failed",
        426: "Upgrade Required",
        500: "Internal Server Error",
        501: "Not Implemented",
        502: "Bad Gateway",
        503: "Service Unavailable",
        504: "Gateway Timeout",
        505: "HTTP Version Not Supported"
      };
      var SyncRequest = class _SyncRequest {
        constructor(resource, init = {}) {
          for (const option of REQ_UNSUPPORTED) {
            if (option in init) {
              throw new TypeError(`option ${option} not supported`);
            }
          }
          if (init.credentials === "same-origin") {
            throw new TypeError("option credentials with value 'same-origin' not supported");
          }
          this[INTERNALS] = {
            method: init.method || "GET",
            headers: new syncFetch.Headers(init.headers),
            body: parseBody(init.body),
            credentials: init.credentials || "omit",
            // Non-spec
            timeout: init.timeout || 0
          };
          if (typeof resource === "string") {
            this[INTERNALS].url = resource;
          } else if (resource instanceof _SyncRequest) {
            this[INTERNALS].url = resource.url;
            if (!init.method) {
              this[INTERNALS].method = resource.method;
            }
            if (!init.headers) {
              this[INTERNALS].headers = resource.headers;
            }
            if (!init.body) {
              this[INTERNALS].body = resource[INTERNALS].body;
            }
            if (!init.credentials) {
              this[INTERNALS].credentials = resource.credentials;
            }
          } else {
            throw new TypeError("Request input should be a URL string or a Request object");
          }
        }
        get cache() {
          return "default";
        }
        get credentials() {
          return this[INTERNALS].credentials;
        }
        get destination() {
          return "";
        }
        get headers() {
          return this[INTERNALS].headers;
        }
        get integrity() {
          return "";
        }
        get method() {
          return this[INTERNALS].method;
        }
        get mode() {
          return "cors";
        }
        get priority() {
          return "auto";
        }
        get redirect() {
          return "follow";
        }
        get referrer() {
          return "about:client";
        }
        get referrerPolicy() {
          return "";
        }
        get url() {
          return this[INTERNALS].url;
        }
        clone() {
          checkBody(this);
          return new _SyncRequest(this.url, this[INTERNALS]);
        }
      };
      var SyncResponse = class _SyncResponse {
        constructor(body, init = {}) {
          this[INTERNALS] = {
            body: parseBody(body),
            bodyUsed: false,
            headers: new syncFetch.Headers(init.headers),
            status: init.status,
            statusText: init.statusText
          };
        }
        get headers() {
          return this[INTERNALS].headers;
        }
        get ok() {
          const status = this[INTERNALS].status;
          return status >= 200 && status < 300;
        }
        get redirected() {
          return this[INTERNALS].redirected;
        }
        get status() {
          return this[INTERNALS].status;
        }
        get statusText() {
          return this[INTERNALS].statusText;
        }
        get url() {
          return this[INTERNALS].url;
        }
        clone() {
          return this.redirect(this[INTERNALS].url, this[INTERNALS].status);
        }
        redirect(url, status) {
          checkBody(this);
          const response = new _SyncResponse(this[INTERNALS].body, {
            headers: this[INTERNALS].headers,
            status: status || this[INTERNALS].status,
            statusText: HTTP_STATUS[status] || this[INTERNALS].statusText
          });
          response[INTERNALS].url = url || this[INTERNALS].url;
          response[INTERNALS].redirected = this[INTERNALS].redirected;
          return response;
        }
      };
      var Body = class _Body {
        constructor(body) {
          this[INTERNALS] = {
            body: parseBody(body),
            bodyUsed: false
          };
        }
        get bodyUsed() {
          return this[INTERNALS].bodyUsed;
        }
        static mixin(prototype) {
          for (const name of Object.getOwnPropertyNames(_Body.prototype)) {
            if (name === "constructor") {
              continue;
            }
            const desc = Object.getOwnPropertyDescriptor(_Body.prototype, name);
            Object.defineProperty(prototype, name, { ...desc, enumerable: true });
          }
        }
        arrayBuffer() {
          const buffer = consumeBody(this);
          return buffer.buffer.slice(buffer.byteOffset, buffer.byteOffset + buffer.byteLength);
        }
        blob() {
          const type = this.headers && this.headers.get("content-type");
          return new Blob([consumeBody(this)], type && { type });
        }
        text() {
          return textDecoder.decode(consumeBody(this));
        }
        json() {
          try {
            return JSON.parse(this.text());
          } catch (err) {
            throw new TypeError(`invalid json response body at ${this.url} reason: ${err.message}`, "invalid-json");
          }
        }
      };
      function checkBody(body) {
        if (body.bodyUsed) {
          throw new TypeError(`body used already for: ${body.url}`);
        }
      }
      function consumeBody(body) {
        checkBody(body);
        body[INTERNALS].bodyUsed = true;
        return body[INTERNALS].body || new Uint8Array();
      }
      function parseBody(body) {
        if (typeof body === "string") {
          return textEncoder.encode(body);
        } else if (body) {
          return body;
        } else {
          return null;
        }
      }
      Body.mixin(SyncRequest.prototype);
      Body.mixin(SyncResponse.prototype);
      var Headers = class {
        constructor(headers) {
          if (headers instanceof syncFetch.Headers) {
            this[INTERNALS] = { ...headers[INTERNALS] };
          } else {
            this[INTERNALS] = {};
            if (Array.isArray(headers)) {
              for (const [name, value] of headers) {
                this.append(name, value);
              }
            } else if (typeof headers === "object") {
              for (const name in headers) {
                this.set(name, headers[name]);
              }
            }
          }
        }
        // modification
        append(name, value) {
          name = name.toLowerCase();
          if (!this[INTERNALS][name]) {
            this[INTERNALS][name] = [];
          }
          this[INTERNALS][name].push(value);
        }
        delete(name) {
          delete this[INTERNALS][name.toLowerCase()];
        }
        set(name, value) {
          this[INTERNALS][name.toLowerCase()] = [value];
        }
        // access
        entries() {
          const pairs = [];
          for (const name in this[INTERNALS]) {
            for (const value of this[INTERNALS][name]) {
              pairs.push([name, value]);
            }
          }
          return pairs;
        }
        get(name) {
          name = name.toLowerCase();
          return name in this[INTERNALS] ? this[INTERNALS][name].join(", ") : null;
        }
        keys() {
          return Object.keys(this[INTERNALS]);
        }
        has(name) {
          return name.toLowerCase() in this[INTERNALS];
        }
        values() {
          const values = [];
          for (const name in this[INTERNALS]) {
            for (const value of this[INTERNALS][name]) {
              values.push(value);
            }
          }
          return values;
        }
        *[Symbol.iterator]() {
          for (const name in this[INTERNALS]) {
            for (const value of this[INTERNALS][name]) {
              yield [name, value];
            }
          }
        }
      };
      syncFetch.Headers = Headers;
      syncFetch.Request = SyncRequest;
      syncFetch.Response = SyncResponse;
      module.exports = syncFetch;
    }
  });

  // common/language/language.ts
  var LanguageID = /* @__PURE__ */ ((LanguageID2) => {
    LanguageID2["LanguageEnglish"] = "English";
    LanguageID2["LanguagePersian"] = "Persian";
    return LanguageID2;
  })(LanguageID || {});

  // common/language/data.ts
  var languageMaps = {
    ["English" /* LanguageEnglish */]: {
      id: "English" /* LanguageEnglish */,
      name: "English",
      local_name: "English",
      flag: "en"
    },
    ["Persian" /* LanguagePersian */]: {
      id: "Persian" /* LanguagePersian */,
      name: "Persian",
      local_name: "\u0641\u0627\u0631\u0633\u06CC",
      flag: "fa"
    }
  };
  var languageMapsValues = Object.values(languageMaps);

  // common/cli/error.ts
  function handleMissingArguments(type) {
    console.error("Error: Missing arguments. Please provide at least one argument.");
    showUsage(type);
    return 1;
  }
  function hasExtraArguments(args) {
    const command = args.find((arg) => !arg.startsWith("--") && arg !== lang_flag);
    if (args.length > 2) {
      const commandName = command ? `"${command}"` : "This command";
      console.error(`Error: ${commandName} does not accept additional arguments.`);
      return true;
    }
    return false;
  }

  // common/cli/command/help.ts
  function showAvailableLanguages() {
    console.log("Available languages:");
    languageMapsValues.forEach((lang) => console.log(`  ${lang.flag} - ${lang.name}`));
  }
  function showUsage(type) {
    console.log(`Usage: ./salam-${type} [options] <command>

        Commands:
          version         Display the version of Salam CLI.
          help            Display this help message.
          file <path>     Process a file with the specified path.
          code <value>    Process the provided code snippet.

        Options:
          ${lang_flag} <value>    Select the language to use.`);
    showAvailableLanguages();
  }
  function processCommandHelp(type, args) {
    if (hasExtraArguments(args)) {
      return 1;
    }
    showUsage(type);
    return 0;
  }

  // common/language/utils.ts
  function getLanguageIDByFlag(flag) {
    return languageMapsValues.find((lang) => lang.flag === flag)?.id;
  }

  // common/cli/language.ts
  var lang_flag = "--lang";
  function processLanguageFlag(args, selectedLanguage) {
    const langFlagIndex = args.findIndex((arg) => arg === lang_flag);
    if (langFlagIndex !== -1) {
      const langValue = args[langFlagIndex + 1];
      if (!langValue) {
        console.error(`Error: Missing value for ${lang_flag} flag.`);
        showAvailableLanguages();
        return 1;
      }
      const languageId = getLanguageIDByFlag(langValue);
      if (languageId !== void 0) {
        const language = languageMaps[languageId];
        Object.assign(selectedLanguage, language);
        return 0;
      } else {
        console.error(`Error: Invalid language value "${langValue}".`);
        showAvailableLanguages();
        return 1;
      }
    }
    return -1;
  }

  // phase/lexer/tokenizer/type.ts
  var TokenKeywordDataType = /* @__PURE__ */ ((TokenKeywordDataType2) => {
    TokenKeywordDataType2["TOKEN_DATA_TYPE_BOOL"] = "DATA_TYPE_BOOL";
    TokenKeywordDataType2["TOKEN_DATA_TYPE_INT"] = "DATA_TYPE_INT";
    TokenKeywordDataType2["TOKEN_DATA_TYPE_FLOAT"] = "DATA_TYPE_FLOAT";
    TokenKeywordDataType2["TOKEN_DATA_TYPE_STRING"] = "DATA_TYPE_STRING";
    TokenKeywordDataType2["TOKEN_DATA_TYPE_CHAR"] = "DATA_TYPE_CHAR";
    return TokenKeywordDataType2;
  })(TokenKeywordDataType || {});
  var TokenKeywordDataTypeValues = Object.values(TokenKeywordDataType);
  function isDataTypeToken(token) {
    return TokenKeywordDataTypeValues.includes(token.type);
  }
  var TokenKeywordType = /* @__PURE__ */ ((TokenKeywordType2) => {
    TokenKeywordType2["TOKEN_IDENTIFIER"] = "IDENTIFIER";
    TokenKeywordType2["TOKEN_DEFER"] = "DEFER";
    TokenKeywordType2["TOKEN_IF"] = "IF";
    TokenKeywordType2["TOKEN_ELSE"] = "ELSE";
    TokenKeywordType2["TOKEN_PRINT"] = "PRINT";
    TokenKeywordType2["TOKEN_FN"] = "FN";
    TokenKeywordType2["TOKEN_FOR"] = "FOR";
    TokenKeywordType2["TOKEN_WHILE"] = "WHILE";
    TokenKeywordType2["TOKEN_REPEAT"] = "REPEAT";
    TokenKeywordType2["TOKEN_DO"] = "DO";
    TokenKeywordType2["TOKEN_RET"] = "RET";
    TokenKeywordType2["TOKEN_BREAK"] = "BREAK";
    TokenKeywordType2["TOKEN_CONTINUE"] = "CONTINUE";
    TokenKeywordType2["TOKEN_LAYOUT"] = "LAYOUT";
    TokenKeywordType2["TOKEN_BLOCK_END"] = "BLOCK_END";
    TokenKeywordType2["TOKEN_BOOL_TRUE"] = "BOOL_TRUE";
    TokenKeywordType2["TOKEN_BOOL_FALSE"] = "BOOL_FALSE";
    return TokenKeywordType2;
  })(TokenKeywordType || {});
  var TokenValueType = /* @__PURE__ */ ((TokenValueType2) => {
    TokenValueType2["TOKEN_STRING"] = "STRING";
    TokenValueType2["TOKEN_NUMBER_FLOAT"] = "NUMBER_FLOAT";
    TokenValueType2["TOKEN_NUMBER_INT"] = "NUMBER_INT";
    TokenValueType2["TOKEN_BOOL_TRUE"] = "BOOL_TRUE";
    TokenValueType2["TOKEN_BOOL_FALSE"] = "BOOL_FALSE";
    return TokenValueType2;
  })(TokenValueType || {});
  var TokenOperatorType = /* @__PURE__ */ ((TokenOperatorType2) => {
    TokenOperatorType2["TOKEN_QUESTION"] = "TOKEN_QUESTION";
    TokenOperatorType2["TOKEN_NOT_EQUAL"] = "NOT_EQUAL";
    TokenOperatorType2["TOKEN_EQUAL"] = "EQUAL";
    TokenOperatorType2["TOKEN_AND_AND"] = "AND_AND";
    TokenOperatorType2["TOKEN_OR_OR"] = "OR_OR";
    TokenOperatorType2["TOKEN_LESS_EQUAL"] = "LESS_EQUAL";
    TokenOperatorType2["TOKEN_GREATER_EQUAL"] = "GREATER_EQUAL";
    TokenOperatorType2["TOKEN_INCREMENT"] = "INCREMENT";
    TokenOperatorType2["TOKEN_DECREMENT"] = "DECREMENT";
    TokenOperatorType2["TOKEN_SHIFT_LEFT"] = "SHIFT_LEFT";
    TokenOperatorType2["TOKEN_SHIFT_RIGHT"] = "SHIFT_RIGHT";
    TokenOperatorType2["TOKEN_SHIFT_RIGHT_ASSIGN"] = "SHIFT_RIGHT_ASSIGN";
    TokenOperatorType2["TOKEN_SHIFT_LEFT_ASSIGN"] = "SHIFT_LEFT_ASSIGN";
    TokenOperatorType2["TOKEN_LEFT_BRACE"] = "LEFT_BRACE";
    TokenOperatorType2["TOKEN_RIGHT_BRACE"] = "RIGHT_BRACE";
    TokenOperatorType2["TOKEN_LEFT_BRACKET"] = "LEFT_BRACKET";
    TokenOperatorType2["TOKEN_RIGHT_BRACKET"] = "RIGHT_BRACKET";
    TokenOperatorType2["TOKEN_COLON"] = "COLON";
    TokenOperatorType2["TOKEN_COLON_COLON"] = "COLON_COLON";
    TokenOperatorType2["TOKEN_COMMA"] = "COMMA";
    TokenOperatorType2["TOKEN_LEFT_PAREN"] = "LEFT_PAREN";
    TokenOperatorType2["TOKEN_RIGHT_PAREN"] = "RIGHT_PAREN";
    TokenOperatorType2["TOKEN_PLUS"] = "PLUS";
    TokenOperatorType2["TOKEN_MINUS"] = "MINUS";
    TokenOperatorType2["TOKEN_MULTIPLY"] = "MULTIPLY";
    TokenOperatorType2["TOKEN_DIVIDE"] = "DIVIDE";
    TokenOperatorType2["TOKEN_MODULO"] = "MOD";
    TokenOperatorType2["TOKEN_POWER"] = "POWER";
    TokenOperatorType2["TOKEN_ASSIGN"] = "ASSIGN";
    TokenOperatorType2["TOKEN_LESS"] = "LESS";
    TokenOperatorType2["TOKEN_GREATER"] = "GREATER";
    TokenOperatorType2["TOKEN_NOT"] = "NOT";
    TokenOperatorType2["TOKEN_AND_BIT"] = "AND_BIT";
    TokenOperatorType2["TOKEN_OR_BIT"] = "OR_BIT";
    TokenOperatorType2["TOKEN_XOR_BIT"] = "XOR_BIT";
    TokenOperatorType2["TOKEN_MEMBER"] = "MEMBER";
    TokenOperatorType2["TOKEN_MEMBER_POINTER"] = "TOKEN_MEMBER_POINTER";
    TokenOperatorType2["TOKEN_RANGE"] = "RANGE";
    return TokenOperatorType2;
  })(TokenOperatorType || {});
  var TokenOtherType = /* @__PURE__ */ ((TokenOtherType2) => {
    TokenOtherType2["TOKEN_ERROR"] = "ERROR";
    TokenOtherType2["TOKEN_EOF"] = "EOF";
    return TokenOtherType2;
  })(TokenOtherType || {});

  // serializer.ts
  function stringify(obj, wantsJson = true) {
    if (wantsJson) {
      return JSON.stringify(obj, null, 2);
    }
    return obj;
  }

  // phase/lexer/tokenizer/token.ts
  var Token = class {
    constructor(type, location, enduser_token, data) {
      this.type = type;
      this.location = location;
      this.enduser_token = enduser_token;
      this.data = data;
    }
    get enduser() {
      return this.enduser_token || this.type;
    }
    get isValue() {
      for (const value of Object.values(TokenValueType)) {
        if (this.type === value) {
          return true;
        }
      }
      return false;
    }
    get isKeyword() {
      if (this.type === "BLOCK_END" /* TOKEN_BLOCK_END */) {
        return false;
      }
      for (const value of Object.values(TokenKeywordType)) {
        if (this.type === value) {
          return true;
        }
      }
      return false;
    }
    get isUserIdentifier() {
      return this.isKeyword && this.type === "IDENTIFIER" /* TOKEN_IDENTIFIER */;
    }
    get isDefinedIdentifier() {
      return this.isKeyword && this.type !== "IDENTIFIER" /* TOKEN_IDENTIFIER */;
    }
    getTypeString(enumType) {
      const values = Object.values(enumType);
      return values.includes(this.type) ? this.type : void 0;
    }
    stringify(wantsJson = true) {
      const typeString = this.getTypeString(TokenKeywordType) || this.getTypeString(TokenValueType) || this.getTypeString(TokenOperatorType) || this.getTypeString(TokenOtherType);
      const obj = {
        type: typeString,
        enduser_token: this.enduser_token,
        location: this.location.stringify(false),
        data: this.data?.stringify(false) || void 0
      };
      return stringify(obj, wantsJson);
    }
  };
  function arrayName2String(array) {
    return array.map((token) => token.data?.getValueString()).filter((value) => value).join(" ");
  }

  // phase/lexer/lex/utf8.ts
  function isUtf8Alpha(char) {
    return /^[\_a-zA-Z\u0600-\u06FF]+$/.test(char);
  }
  function isEnglishDigit(char) {
    return /^\d+$/.test(char);
  }
  function isPersianDigit(char) {
    return /^[\u06F0-\u06F9]+$/.test(char);
  }
  function isArabicDigit(char) {
    return /^[\u0660-\u0669]+$/.test(char);
  }
  function isUtf8Number(char) {
    return isArabicDigit(char) || isPersianDigit(char) || isEnglishDigit(char);
  }
  function toEnglishDigit(char) {
    return char.replace(/[\u06F0-\u06F9\u0660-\u0669]/g, (d) => String.fromCharCode(d.charCodeAt(0) - 1728));
  }

  // phase/lexer/tokenizer/data.ts
  var TokenDataType = /* @__PURE__ */ ((TokenDataType2) => {
    TokenDataType2[TokenDataType2["TOKEN_DATA_TYPE_INT"] = 0] = "TOKEN_DATA_TYPE_INT";
    TokenDataType2[TokenDataType2["TOKEN_DATA_TYPE_FLOAT"] = 1] = "TOKEN_DATA_TYPE_FLOAT";
    TokenDataType2[TokenDataType2["TOKEN_DATA_TYPE_STRING"] = 2] = "TOKEN_DATA_TYPE_STRING";
    TokenDataType2[TokenDataType2["TOKEN_DATA_TYPE_BOOLEAN"] = 3] = "TOKEN_DATA_TYPE_BOOLEAN";
    return TokenDataType2;
  })(TokenDataType || {});
  var TokenData = class {
    constructor(type, value) {
      this.type = type;
      switch (type) {
        case 0 /* TOKEN_DATA_TYPE_INT */:
          this.numberInt = typeof value === "number" ? Math.floor(value) : void 0;
          break;
        case 1 /* TOKEN_DATA_TYPE_FLOAT */:
          this.numberFloat = typeof value === "number" ? value : void 0;
          break;
        case 2 /* TOKEN_DATA_TYPE_STRING */:
          this.string = typeof value === "string" ? value : void 0;
          break;
        case 3 /* TOKEN_DATA_TYPE_BOOLEAN */:
          this.boolean = typeof value === "boolean" ? value : void 0;
          break;
        default:
          throw new Error("Invalid TokenDataType provided");
      }
    }
    getValue() {
      switch (this.type) {
        case 0 /* TOKEN_DATA_TYPE_INT */:
          return this.numberInt ?? void 0;
        case 1 /* TOKEN_DATA_TYPE_FLOAT */:
          return this.numberFloat ?? void 0;
        case 2 /* TOKEN_DATA_TYPE_STRING */:
          return this.string ?? void 0;
        case 3 /* TOKEN_DATA_TYPE_BOOLEAN */:
          return this.boolean ?? void 0;
      }
    }
    getValueString() {
      const value = this.getValue();
      if (value === void 0) {
        return "undefined";
      }
      return value.toString();
    }
    stringify(wantsJson = true) {
      const obj = {
        type: TokenDataType[this.type],
        value: this.getValue()
      };
      return stringify(obj, wantsJson);
    }
  };

  // phase/lexer/lex/number.ts
  function lexerLexNumber(lexer) {
    let value = "";
    let isFloat = false;
    while (lexer.currentChar !== "\0") {
      const char = lexer.currentChar;
      if (char === "." && !isFloat) {
        isFloat = true;
      } else if (!isUtf8Number(char)) {
        break;
      }
      value += toEnglishDigit(char);
      lexer.advance();
    }
    const data = new TokenData(
      isFloat ? 1 /* TOKEN_DATA_TYPE_FLOAT */ : 0 /* TOKEN_DATA_TYPE_INT */,
      isFloat ? parseFloat(value) : parseInt(value, 10)
    );
    const token = new Token(
      isFloat ? "NUMBER_FLOAT" /* TOKEN_NUMBER_FLOAT */ : "NUMBER_INT" /* TOKEN_NUMBER_INT */,
      lexer.getLocation(),
      value,
      data
    );
    lexer.pushToken(token);
  }

  // phase/lexer/tokenizer/keyword.ts
  var keywordMaps = [
    {
      id: "IDENTIFIER" /* TOKEN_IDENTIFIER */
    },
    {
      id: "DEFER" /* TOKEN_DEFER */,
      data: {
        ["English" /* LanguageEnglish */]: ["defer"],
        ["Persian" /* LanguagePersian */]: ["\u0627\u062C\u0631\u0627"]
      }
    },
    {
      id: "IF" /* TOKEN_IF */,
      data: {
        ["English" /* LanguageEnglish */]: ["if"],
        ["Persian" /* LanguagePersian */]: ["\u0627\u06AF\u0631"]
      }
    },
    {
      id: "ELSE" /* TOKEN_ELSE */,
      data: {
        ["English" /* LanguageEnglish */]: ["else"],
        ["Persian" /* LanguagePersian */]: ["\u0648\u06AF\u0631\u0646\u0647"]
      }
    },
    {
      id: "PRINT" /* TOKEN_PRINT */,
      data: {
        ["English" /* LanguageEnglish */]: ["print"],
        ["Persian" /* LanguagePersian */]: ["\u0686\u0627\u067E", "\u0646\u0645\u0627\u06CC\u0634"]
      }
    },
    {
      id: "FN" /* TOKEN_FN */,
      data: {
        ["English" /* LanguageEnglish */]: ["fn"],
        ["Persian" /* LanguagePersian */]: ["\u062A\u0627\u0628\u0639"]
      }
    },
    {
      id: "FOR" /* TOKEN_FOR */,
      data: {
        ["English" /* LanguageEnglish */]: ["for"],
        ["Persian" /* LanguagePersian */]: ["\u0628\u0631\u0627\u06CC"]
      }
    },
    {
      id: "WHILE" /* TOKEN_WHILE */,
      data: {
        ["English" /* LanguageEnglish */]: ["while"],
        ["Persian" /* LanguagePersian */]: ["\u062A\u0627"]
      }
    },
    {
      id: "REPEAT" /* TOKEN_REPEAT */,
      data: {
        ["English" /* LanguageEnglish */]: ["repeat"],
        ["Persian" /* LanguagePersian */]: ["\u062A\u06A9\u0631\u0627\u0631"]
      }
    },
    {
      id: "DO" /* TOKEN_DO */,
      data: {
        ["English" /* LanguageEnglish */]: ["do"],
        ["Persian" /* LanguagePersian */]: ["\u0627\u0646\u062C\u0627\u0645"]
      }
    },
    {
      id: "RET" /* TOKEN_RET */,
      data: {
        ["English" /* LanguageEnglish */]: ["ret"],
        ["Persian" /* LanguagePersian */]: ["\u0628\u0631\u06AF\u0634\u062A"]
      }
    },
    {
      id: "BREAK" /* TOKEN_BREAK */,
      data: {
        ["English" /* LanguageEnglish */]: ["break"],
        ["Persian" /* LanguagePersian */]: ["\u0634\u06A9\u0633\u062A"]
      }
    },
    {
      id: "CONTINUE" /* TOKEN_CONTINUE */,
      data: {
        ["English" /* LanguageEnglish */]: ["continue"],
        ["Persian" /* LanguagePersian */]: ["\u0627\u062F\u0627\u0645\u0647"]
      }
    },
    {
      id: "LAYOUT" /* TOKEN_LAYOUT */,
      data: {
        ["English" /* LanguageEnglish */]: ["layout"],
        ["Persian" /* LanguagePersian */]: ["\u0644\u0627\u06CC\u0647"]
      }
    },
    {
      id: "BLOCK_END" /* TOKEN_BLOCK_END */,
      data: {
        ["English" /* LanguageEnglish */]: ["end"],
        ["Persian" /* LanguagePersian */]: ["\u062A\u0645\u0627\u0645"]
      }
    },
    // Types
    {
      id: "DATA_TYPE_INT" /* TOKEN_DATA_TYPE_INT */,
      data: {
        ["English" /* LanguageEnglish */]: ["int"],
        ["Persian" /* LanguagePersian */]: ["\u0635\u062D\u06CC\u062D"]
      }
    },
    {
      id: "DATA_TYPE_FLOAT" /* TOKEN_DATA_TYPE_FLOAT */,
      data: {
        ["English" /* LanguageEnglish */]: ["float"],
        ["Persian" /* LanguagePersian */]: ["\u0627\u0639\u0634\u0627\u0631"]
      }
    },
    {
      id: "DATA_TYPE_CHAR" /* TOKEN_DATA_TYPE_CHAR */,
      data: {
        ["English" /* LanguageEnglish */]: ["char"],
        ["Persian" /* LanguagePersian */]: ["\u062D\u0631\u0641"]
      }
    },
    {
      id: "DATA_TYPE_STRING" /* TOKEN_DATA_TYPE_STRING */,
      data: {
        ["English" /* LanguageEnglish */]: ["string"],
        ["Persian" /* LanguagePersian */]: ["\u0631\u0634\u062A\u0647"]
      }
    },
    {
      id: "DATA_TYPE_BOOL" /* TOKEN_DATA_TYPE_BOOL */,
      data: {
        ["English" /* LanguageEnglish */]: ["bool"],
        ["Persian" /* LanguagePersian */]: ["\u062F\u0631\u0633\u062A\u06CC"]
      }
    },
    {
      id: "BOOL_TRUE" /* TOKEN_BOOL_TRUE */,
      data: {
        ["English" /* LanguageEnglish */]: ["true"],
        ["Persian" /* LanguagePersian */]: ["\u062F\u0631\u0633\u062A"]
      }
    },
    {
      id: "BOOL_FALSE" /* TOKEN_BOOL_FALSE */,
      data: {
        ["English" /* LanguageEnglish */]: ["false"],
        ["Persian" /* LanguagePersian */]: ["\u063A\u0644\u0637"]
      }
    }
  ];

  // phase/lexer/lex/identifier.ts
  function lexerLexIdentifier(lexer) {
    let value = "";
    while (lexer.currentChar !== "\0") {
      const char = lexer.currentChar;
      if (!isUtf8Alpha(char) && !isUtf8Number(char)) {
        break;
      }
      value += char;
      lexer.advance();
    }
    const data = new TokenData(2 /* TOKEN_DATA_TYPE_STRING */, value);
    for (const keywordMap of keywordMaps) {
      if (keywordMap.data && keywordMap.data[lexer.language.id].includes(value)) {
        const token2 = new Token(keywordMap.id, lexer.getLocation(), value, data);
        lexer.pushToken(token2);
        return;
      }
    }
    const token = new Token("IDENTIFIER" /* TOKEN_IDENTIFIER */, lexer.getLocation(), value, data);
    lexer.pushToken(token);
  }

  // phase/lexer/lex/comment/single.ts
  function lexerLexReadComment(lexer) {
    lexer.advance();
    lexer.advance();
    while (lexer.currentChar !== "\0" && lexer.currentChar !== "\n") {
      lexer.advance();
    }
  }

  // phase/lexer/lex/string.ts
  var stringOpenings = [
    '"',
    "'",
    "`",
    "\u201C",
    "\xAB",
    "\u2018"
  ];
  var stringClosings = [
    '"',
    "'",
    "`",
    "\u201D",
    "\xBB",
    "\u2019"
  ];
  function lexerLexString(lexer, opening) {
    let value = "";
    lexer.advance();
    const closing = stringClosings[stringOpenings.indexOf(opening)];
    while (lexer.currentChar !== "\0") {
      if (lexer.currentChar === closing) {
        lexer.advance();
        break;
      }
      if (lexer.currentChar === "\\") {
        lexer.advance();
      } else {
        value += lexer.currentChar;
      }
      lexer.advance();
    }
    const tokenData = new TokenData(2 /* TOKEN_DATA_TYPE_STRING */, value);
    const token = new Token("STRING" /* TOKEN_STRING */, lexer.getLocation(), value, tokenData);
    lexer.pushToken(token);
  }

  // common/message/lexer/fa.ts
  var faMessages = {
    ["LEXER_PREFIX" /* LEXER_PREFIX */]: "\u062E\u0637\u0627\u06CC \u0646\u062D\u0648\u06CC: ",
    ["LEXER_INVALID_UNEXPECTED_CHAR" /* LEXER_INVALID_UNEXPECTED_CHAR */]: "\u06A9\u0627\u0631\u0627\u06A9\u062A\u0631 \u063A\u06CC\u0631\u0645\u0646\u062A\u0638\u0631\u0647 '{0}'",
    ["LEXER_UNTERMINATED_MULTI_LINE_COMMENT_BLOCK" /* LEXER_UNTERMINATED_MULTI_LINE_COMMENT_BLOCK */]: "\u0628\u0644\u0648\u06A9 \u06A9\u0627\u0645\u0646\u062A \u0686\u0646\u062F\u062E\u0637\u06CC \u0628\u0633\u062A\u0647 \u0646\u0634\u062F\u0647 \u0627\u0633\u062A",
    ["LEXER_UNCLOSED_STRING_LITERAL" /* LEXER_UNCLOSED_STRING_LITERAL */]: "\u0631\u0634\u062A\u0647 \u0634\u0631\u0648\u0639 \u0634\u062F\u0647 \u0628\u0627 '{0}' \u0628\u0633\u062A\u0647 \u0646\u0634\u062F\u0647 \u0627\u0633\u062A"
  };

  // common/message/lexer/en.ts
  var enMessages = {
    ["LEXER_PREFIX" /* LEXER_PREFIX */]: "Syntax error: ",
    ["LEXER_INVALID_UNEXPECTED_CHAR" /* LEXER_INVALID_UNEXPECTED_CHAR */]: "Unexpected character '{0}'",
    ["LEXER_UNTERMINATED_MULTI_LINE_COMMENT_BLOCK" /* LEXER_UNTERMINATED_MULTI_LINE_COMMENT_BLOCK */]: "Unterminated multi-line comment block",
    ["LEXER_UNCLOSED_STRING_LITERAL" /* LEXER_UNCLOSED_STRING_LITERAL */]: "String literal starting with '{0}' is unclosed"
  };

  // common/message/lexer/message.ts
  var lexerMessages = {
    ["English" /* LanguageEnglish */]: enMessages,
    ["Persian" /* LanguagePersian */]: faMessages
  };

  // common/message/parser/fa.ts
  var faMessages2 = {
    ["PARSER_PREFIX" /* PARSER_PREFIX */]: "\u062E\u0637\u0627\u06CC \u06AF\u0631\u0627\u0645\u0631\u06CC: ",
    ["PARSER_FAILED_TO_PARSE_FUNCTION_STATEMENT" /* PARSER_FAILED_TO_PARSE_FUNCTION_STATEMENT */]: "\u0646\u0627\u062A\u0648\u0627\u0646 \u062F\u0631 \u062A\u062C\u0632\u06CC\u0647 \u0648 \u062A\u062D\u0644\u06CC\u0644 \u0627\u0638\u0647\u0627\u0631\u0627\u062A \u062A\u0627\u0628\u0639.",
    ["PARSER_FAILED_TO_PARSE_FUNCTION" /* PARSER_FAILED_TO_PARSE_FUNCTION */]: "\u0646\u0627\u062A\u0648\u0627\u0646 \u062F\u0631 \u062A\u062C\u0632\u06CC\u0647 \u0648 \u062A\u062D\u0644\u06CC\u0644 \u062A\u0627\u0628\u0639.",
    ["PARSER_FAILED_TO_PARSE_LAYOUT_ELEMENT" /* PARSER_FAILED_TO_PARSE_LAYOUT_ELEMENT */]: "\u0646\u0627\u062A\u0648\u0627\u0646 \u062F\u0631 \u062A\u062C\u0632\u06CC\u0647 \u0648 \u062A\u062D\u0644\u06CC\u0644 \u0639\u0646\u0635\u0631 \u0637\u0631\u062D.",
    ["PARSER_DUPLICATE_LAYOUT_DEFINITION" /* PARSER_DUPLICATE_LAYOUT_DEFINITION */]: "\u062A\u0639\u0631\u06CC\u0641 \u0637\u0631\u062D \u062A\u06A9\u0631\u0627\u0631\u06CC \u0627\u0633\u062A\u060C \u0646\u0645\u06CC\u200C\u062A\u0648\u0627\u0646 \u0628\u06CC\u0634 \u0627\u0632 \u06CC\u06A9 \u062A\u0639\u0631\u06CC\u0641 \u0637\u0631\u062D \u062F\u0631 \u06CC\u06A9 \u0628\u0631\u0646\u0627\u0645\u0647 \u062F\u0627\u0634\u062A.",
    ["PARSER_UNEXPECTED_TOKEN_IN_PROGRAM" /* PARSER_UNEXPECTED_TOKEN_IN_PROGRAM */]: "\u0646\u0634\u0627\u0646\u0647 \u063A\u06CC\u0631\u0645\u0646\u062A\u0638\u0631\u0647 \u062F\u0631 \u0628\u0631\u0646\u0627\u0645\u0647\u060C \u0646\u0634\u0627\u0646\u0647 \u0641\u0639\u0644\u06CC '{0}'",
    ["PARSER_UNEXPECTED_END_OF_TOKENS_IN_LAYOUT_ATTRIBUTE" /* PARSER_UNEXPECTED_END_OF_TOKENS_IN_LAYOUT_ATTRIBUTE */]: "\u067E\u0627\u06CC\u0627\u0646 \u063A\u06CC\u0631\u0645\u0646\u062A\u0638\u0631\u0647 \u0646\u0634\u0627\u0646\u0647\u200C\u0647\u0627 \u062F\u0631 \u0648\u06CC\u0698\u06AF\u06CC \u0637\u0631\u062D",
    ["PARSER_DUPLICATE_STYLE_ATTRIBUTE_IN_LAYOUT" /* PARSER_DUPLICATE_STYLE_ATTRIBUTE_IN_LAYOUT */]: "\u0648\u06CC\u0698\u06AF\u06CC \u0627\u0633\u062A\u0627\u06CC\u0644 \u062A\u06A9\u0631\u0627\u0631\u06CC '{0}' \u062F\u0631 \u0637\u0631\u062D",
    ["PARSER_DUPLICATE_ELEMENT_ATTRIBUTE_IN_LAYOUT" /* PARSER_DUPLICATE_ELEMENT_ATTRIBUTE_IN_LAYOUT */]: "\u0648\u06CC\u0698\u06AF\u06CC \u0639\u0646\u0635\u0631 \u062A\u06A9\u0631\u0627\u0631\u06CC '{0}' \u062F\u0631 \u0637\u0631\u062D",
    ["PARSER_UNEXPECTED_TOKEN_AS_ELEMENT_NAME" /* PARSER_UNEXPECTED_TOKEN_AS_ELEMENT_NAME */]: "\u0646\u0634\u0627\u0646\u0647 \u063A\u06CC\u0631\u0645\u0646\u062A\u0638\u0631\u0647 \u0628\u0647 \u0639\u0646\u0648\u0627\u0646 \u0646\u0627\u0645 \u0639\u0646\u0635\u0631\u060C \u0646\u0634\u0627\u0646\u0647 \u0641\u0639\u0644\u06CC '{0}'",
    ["PARSER_UNEXPECTED_TOKEN_IN_LAYOUT" /* PARSER_UNEXPECTED_TOKEN_IN_LAYOUT */]: "\u0646\u0634\u0627\u0646\u0647 \u063A\u06CC\u0631\u0645\u0646\u062A\u0638\u0631\u0647 \u062F\u0631 \u0637\u0631\u062D\u060C \u0646\u0634\u0627\u0646\u0647 \u0641\u0639\u0644\u06CC '{0}'",
    ["PARSER_UNEXPECTED_TOKEN_IN_LAYOUT_AS_ATTRIBUTE" /* PARSER_UNEXPECTED_TOKEN_IN_LAYOUT_AS_ATTRIBUTE */]: "\u0646\u0634\u0627\u0646\u0647 \u063A\u06CC\u0631\u0645\u0646\u062A\u0638\u0631\u0647 \u062F\u0631 \u0637\u0631\u062D \u0628\u0647 \u0639\u0646\u0648\u0627\u0646 \u0648\u06CC\u0698\u06AF\u06CC\u060C \u0646\u0634\u0627\u0646\u0647 \u0641\u0639\u0644\u06CC '{0}'",
    ["PARSER_FUNCTION_NAME_IS_NOT_VALID_IDENTIFIER" /* PARSER_FUNCTION_NAME_IS_NOT_VALID_IDENTIFIER */]: "\u0646\u0627\u0645 \u062A\u0627\u0628\u0639 \u0645\u0639\u062A\u0628\u0631 \u0646\u06CC\u0633\u062A\u060C \u0628\u0627\u06CC\u062F \u06CC\u06A9 \u0631\u0634\u062A\u0647 \u0634\u0646\u0627\u0633\u0647 \u0628\u0627\u0634\u062F.",
    ["PARSER_FUNCTION_NAME_IS_RESERVED_IN_SALAM" /* PARSER_FUNCTION_NAME_IS_RESERVED_IN_SALAM */]: "\u0646\u0627\u0645 \u062A\u0627\u0628\u0639 \u0645\u0639\u062A\u0628\u0631 \u0646\u06CC\u0633\u062A\u060C \u0627\u06CC\u0646 \u0646\u0627\u0645 \u062F\u0631 Salam \u0627\u0632 \u0642\u0628\u0644 \u0631\u0632\u0631\u0648 \u0634\u062F\u0647 \u0627\u0633\u062A\u060C \u0628\u0627\u06CC\u062F \u0646\u0627\u0645 \u062F\u06CC\u06AF\u0631\u06CC \u0627\u0646\u062A\u062E\u0627\u0628 \u06A9\u0646\u06CC\u062F.",
    ["PARSER_FUNCTION_NAME_IS_NOT_VALID" /* PARSER_FUNCTION_NAME_IS_NOT_VALID */]: "\u0646\u0627\u0645 \u062A\u0627\u0628\u0639 \u0645\u0639\u062A\u0628\u0631 \u0646\u06CC\u0633\u062A.",
    ["PARSER_FUNCTION_PARAMETERS_ARE_NOT_VALID" /* PARSER_FUNCTION_PARAMETERS_ARE_NOT_VALID */]: "\u067E\u0627\u0631\u0627\u0645\u062A\u0631\u0647\u0627\u06CC \u062A\u0627\u0628\u0639 \u0645\u0639\u062A\u0628\u0631 \u0646\u06CC\u0633\u062A\u0646\u062F.",
    ["PARSER_FUNCTION_BODY_IS_NOT_VALID" /* PARSER_FUNCTION_BODY_IS_NOT_VALID */]: "\u0628\u062F\u0646\u0647 \u062A\u0627\u0628\u0639 \u0645\u0639\u062A\u0628\u0631 \u0646\u06CC\u0633\u062A.",
    ["PARSER_EXPECTED_TOKEN_DATA_TYPE_BUT_GOT" /* PARSER_EXPECTED_TOKEN_DATA_TYPE_BUT_GOT */]: "\u0646\u0648\u0639 \u0646\u0634\u0627\u0646\u0647 {0} \u0627\u0646\u062A\u0638\u0627\u0631 \u0645\u06CC\u200C\u0631\u0641\u062A\u060C \u0627\u0645\u0627 {1} \u062F\u0631\u06CC\u0627\u0641\u062A \u0634\u062F.",
    ["PARSER_STATEMENT_IS_NOT_VALID_IN_BLOCK" /* PARSER_STATEMENT_IS_NOT_VALID_IN_BLOCK */]: "\u0627\u06CC\u0646 \u062F\u0633\u062A\u0648\u0631 \u062F\u0631 \u0628\u0644\u0648\u06A9 \u0645\u0639\u062A\u0628\u0631 \u0646\u06CC\u0633\u062A.",
    ["PARSER_EXPRESSION_EXPECTED_AFTER_OPERATOR" /* PARSER_EXPRESSION_EXPECTED_AFTER_OPERATOR */]: "\u0645\u0642\u062F\u0627\u0631\u06CC \u0628\u0639\u062F \u0627\u0632 \u0639\u0645\u0644\u06AF\u0631 '{0}' \u0627\u0646\u062A\u0638\u0627\u0631 \u0645\u06CC\u200C\u0631\u0641\u062A.",
    ["PARSER_EXPRESSION_EXPECTED_AFTER_UNARY_OPERATOR" /* PARSER_EXPRESSION_EXPECTED_AFTER_UNARY_OPERATOR */]: "\u0645\u0642\u062F\u0627\u0631\u06CC \u0628\u0639\u062F \u0627\u0632 \u0639\u0645\u0644\u06AF\u0631 \u06CC\u06A9\u200C\u062A\u0627\u06CC\u06CC '{0}' \u0627\u0646\u062A\u0638\u0627\u0631 \u0645\u06CC\u200C\u0631\u0641\u062A.",
    ["PARSER_EXPRESSION_EXPECTED_IN_STATEMENT" /* PARSER_EXPRESSION_EXPECTED_IN_STATEMENT */]: "\u0645\u0642\u062F\u0627\u0631\u06CC \u062F\u0631 \u062F\u0633\u062A\u0648\u0631 '{0}' \u0627\u0646\u062A\u0638\u0627\u0631 \u0645\u06CC\u200C\u0631\u0641\u062A."
  };

  // common/message/parser/en.ts
  var enMessages2 = {
    ["PARSER_PREFIX" /* PARSER_PREFIX */]: "Parser error: ",
    ["PARSER_FAILED_TO_PARSE_FUNCTION_STATEMENT" /* PARSER_FAILED_TO_PARSE_FUNCTION_STATEMENT */]: "Failed to parse function staement.",
    ["PARSER_FAILED_TO_PARSE_FUNCTION" /* PARSER_FAILED_TO_PARSE_FUNCTION */]: "Failed to parse function.",
    ["PARSER_FAILED_TO_PARSE_LAYOUT_ELEMENT" /* PARSER_FAILED_TO_PARSE_LAYOUT_ELEMENT */]: "Failed to parse layout element.",
    ["PARSER_DUPLICATE_LAYOUT_DEFINITION" /* PARSER_DUPLICATE_LAYOUT_DEFINITION */]: "Duplicate layout definition, cannot have more than one layout definition in a program.",
    ["PARSER_UNEXPECTED_TOKEN_IN_PROGRAM" /* PARSER_UNEXPECTED_TOKEN_IN_PROGRAM */]: "Unexpected token in program, current token is '{0}'",
    ["PARSER_UNEXPECTED_END_OF_TOKENS_IN_LAYOUT_ATTRIBUTE" /* PARSER_UNEXPECTED_END_OF_TOKENS_IN_LAYOUT_ATTRIBUTE */]: "Unexpected end of tokens in layout attribute",
    ["PARSER_DUPLICATE_STYLE_ATTRIBUTE_IN_LAYOUT" /* PARSER_DUPLICATE_STYLE_ATTRIBUTE_IN_LAYOUT */]: "Duplicate style attribute '{0}' in layout",
    ["PARSER_DUPLICATE_ELEMENT_ATTRIBUTE_IN_LAYOUT" /* PARSER_DUPLICATE_ELEMENT_ATTRIBUTE_IN_LAYOUT */]: "Duplicate element attribute '{0}' in layout",
    ["PARSER_UNEXPECTED_TOKEN_AS_ELEMENT_NAME" /* PARSER_UNEXPECTED_TOKEN_AS_ELEMENT_NAME */]: "Unexpected token as element name, current token is '{0}'",
    ["PARSER_UNEXPECTED_TOKEN_IN_LAYOUT" /* PARSER_UNEXPECTED_TOKEN_IN_LAYOUT */]: "Unexpected token in layout, current token is '{0}'",
    ["PARSER_UNEXPECTED_TOKEN_IN_LAYOUT_AS_ATTRIBUTE" /* PARSER_UNEXPECTED_TOKEN_IN_LAYOUT_AS_ATTRIBUTE */]: "Unexpected token in layout as attribute, current token is '{0}'",
    ["PARSER_FUNCTION_NAME_IS_NOT_VALID_IDENTIFIER" /* PARSER_FUNCTION_NAME_IS_NOT_VALID_IDENTIFIER */]: "Function name is not valid, it should be an identifier string name.",
    ["PARSER_FUNCTION_NAME_IS_RESERVED_IN_SALAM" /* PARSER_FUNCTION_NAME_IS_RESERVED_IN_SALAM */]: "Function name is not valid, this name already reserved in Salam, you should choose another name.",
    ["PARSER_FUNCTION_NAME_IS_NOT_VALID" /* PARSER_FUNCTION_NAME_IS_NOT_VALID */]: "Function name is not valid.",
    ["PARSER_FUNCTION_PARAMETERS_ARE_NOT_VALID" /* PARSER_FUNCTION_PARAMETERS_ARE_NOT_VALID */]: "Function parameters are not valid.",
    ["PARSER_FUNCTION_BODY_IS_NOT_VALID" /* PARSER_FUNCTION_BODY_IS_NOT_VALID */]: "Function body is not valid.",
    ["PARSER_EXPECTED_TOKEN_DATA_TYPE_BUT_GOT" /* PARSER_EXPECTED_TOKEN_DATA_TYPE_BUT_GOT */]: "Expected token type {0}, but got {1}.",
    ["PARSER_STATEMENT_IS_NOT_VALID_IN_BLOCK" /* PARSER_STATEMENT_IS_NOT_VALID_IN_BLOCK */]: "Statement is not valid in block.",
    ["PARSER_EXPRESSION_EXPECTED_AFTER_OPERATOR" /* PARSER_EXPRESSION_EXPECTED_AFTER_OPERATOR */]: "Expression expected after operator '{0}'.",
    ["PARSER_EXPRESSION_EXPECTED_AFTER_UNARY_OPERATOR" /* PARSER_EXPRESSION_EXPECTED_AFTER_UNARY_OPERATOR */]: "Expression expected after unary operator '{0}'.",
    ["PARSER_EXPRESSION_EXPECTED_IN_STATEMENT" /* PARSER_EXPRESSION_EXPECTED_IN_STATEMENT */]: "Expression expected in '{0}' statement."
  };

  // common/message/parser/message.ts
  var parserMessages = {
    ["English" /* LanguageEnglish */]: enMessages2,
    ["Persian" /* LanguagePersian */]: faMessages2
  };

  // common/message/validator/fa.ts
  var faMessages3 = {
    ["VALIDATOR_PREFIX" /* VALIDATOR_PREFIX */]: "\u062E\u0637\u0627 \u0627\u0639\u062A\u0628\u0627\u0631\u0633\u0646\u062C\u06CC: ",
    ["VALIDATOR_ATTRIBUTE_REQUIRED" /* VALIDATOR_ATTRIBUTE_REQUIRED */]: "\u0648\u06CC\u0698\u06AF\u06CC '{0}' \u0628\u0631\u0627\u06CC \u0639\u0646\u0635\u0631 '{1}' \u0644\u0627\u0632\u0645 \u0627\u0633\u062A \u0627\u0645\u0627 \u06CC\u0627\u0641\u062A \u0646\u0634\u062F",
    ["VALIDATOR_ELEMENT_NOT_VALID" /* VALIDATOR_ELEMENT_NOT_VALID */]: "\u0639\u0646\u0635\u0631 '{0}' \u06CC\u06A9 \u0639\u0646\u0635\u0631 \u0645\u0639\u062A\u0628\u0631 \u0646\u06CC\u0633\u062A",
    ["VALIDATOR_ELEMENT_STYLE_STATE_NOT_VALID" /* VALIDATOR_ELEMENT_STYLE_STATE_NOT_VALID */]: "\u0648\u0636\u0639\u06CC\u062A \u0627\u0633\u062A\u0627\u06CC\u0644 \u0639\u0646\u0635\u0631 '{0}' \u06CC\u06A9 \u0648\u0636\u0639\u06CC\u062A \u0627\u0633\u062A\u0627\u06CC\u0644 \u0645\u0639\u062A\u0628\u0631 \u0646\u06CC\u0633\u062A",
    ["VALIDATOR_ELEMENT_OR_STYLE_STATE_NOT_VALID" /* VALIDATOR_ELEMENT_OR_STYLE_STATE_NOT_VALID */]: "\u0639\u0646\u0635\u0631 \u06CC\u0627 \u0648\u0636\u0639\u06CC\u062A \u0627\u0633\u062A\u0627\u06CC\u0644 '{0}' \u06CC\u06A9 \u0639\u0646\u0635\u0631 \u06CC\u0627 \u0648\u0636\u0639\u06CC\u062A \u0627\u0633\u062A\u0627\u06CC\u0644 \u0645\u0639\u062A\u0628\u0631 \u0646\u06CC\u0633\u062A",
    ["VALIDATOR_ATTRIBUTE_RESERVED_VALUE_NOT_VALID" /* VALIDATOR_ATTRIBUTE_RESERVED_VALUE_NOT_VALID */]: "\u0645\u0642\u062F\u0627\u0631 \u0648\u06CC\u0698\u06AF\u06CC '{1}' \u0628\u0631\u0627\u06CC \u0648\u06CC\u0698\u06AF\u06CC '{1}' \u062F\u0631 \u0639\u0646\u0635\u0631 '{2}' \u0645\u0639\u062A\u0628\u0631 \u0646\u06CC\u0633\u062A",
    ["VALIDATOR_ATTRIBUTE_NOT_VALID" /* VALIDATOR_ATTRIBUTE_NOT_VALID */]: "\u0648\u06CC\u0698\u06AF\u06CC '{0}' \u0628\u0631\u0627\u06CC \u0639\u0646\u0635\u0631 '{1}' \u0645\u0639\u062A\u0628\u0631 \u0646\u06CC\u0633\u062A",
    ["VALIDATOR_STYLE_ATTRIBUTE_NOT_VALID" /* VALIDATOR_STYLE_ATTRIBUTE_NOT_VALID */]: "\u0648\u06CC\u0698\u06AF\u06CC \u0627\u0633\u062A\u0627\u06CC\u0644 '{0}' \u0628\u0631\u0627\u06CC \u0639\u0646\u0635\u0631 '{1}' \u0645\u0639\u062A\u0628\u0631 \u0646\u06CC\u0633\u062A",
    ["VALIDATOR_ATTRIBUTE_VALUE_NOT_VALID" /* VALIDATOR_ATTRIBUTE_VALUE_NOT_VALID */]: "\u0645\u0642\u062F\u0627\u0631 \u0648\u06CC\u0698\u06AF\u06CC '{0}' \u0628\u0631\u0627\u06CC \u0648\u06CC\u0698\u06AF\u06CC '{1}' \u062F\u0631 \u0639\u0646\u0635\u0631 '{2}' \u06CC\u06A9 \u0645\u0642\u062F\u0627\u0631 \u0645\u0639\u062A\u0628\u0631 \u0646\u06CC\u0633\u062A",
    ["VALIDATOR_ATTRIBUTE_VALUE_NOT_EMPTY" /* VALIDATOR_ATTRIBUTE_VALUE_NOT_EMPTY */]: "\u0645\u0642\u062F\u0627\u0631 \u0648\u06CC\u0698\u06AF\u06CC '{0}' \u062F\u0631 \u0639\u0646\u0635\u0631 '{1}' \u0646\u0628\u0627\u06CC\u062F \u062E\u0627\u0644\u06CC \u0628\u0627\u0634\u062F",
    ["VALIDATOR_ATTRIBUTE_NOT_SUPPORTED" /* VALIDATOR_ATTRIBUTE_NOT_SUPPORTED */]: "\u0648\u06CC\u0698\u06AF\u06CC '{0}' \u0628\u0631\u0627\u06CC \u0639\u0646\u0635\u0631 '{1}' \u067E\u0634\u062A\u06CC\u0628\u0627\u0646\u06CC \u0646\u0645\u06CC \u0634\u0648\u062F",
    ["VALIDATOR_SAVE_OUTPUT_ERROR" /* VALIDATOR_SAVE_OUTPUT_ERROR */]: "\u062E\u0637\u0627 \u062F\u0631 \u0630\u062E\u06CC\u0631\u0647 \u062F\u0631\u062E\u062A \u062F\u0631 \u0641\u0627\u06CC\u0644 '{0}' - {1}"
  };

  // common/message/validator/en.ts
  var enMessages3 = {
    ["VALIDATOR_PREFIX" /* VALIDATOR_PREFIX */]: "Validation error: ",
    ["VALIDATOR_ATTRIBUTE_REQUIRED" /* VALIDATOR_ATTRIBUTE_REQUIRED */]: "Attribute '{0}' is required for element '{1}}' but not found",
    ["VALIDATOR_ELEMENT_NOT_VALID" /* VALIDATOR_ELEMENT_NOT_VALID */]: "Element '{0}' is not a valid element",
    ["VALIDATOR_ELEMENT_STYLE_STATE_NOT_VALID" /* VALIDATOR_ELEMENT_STYLE_STATE_NOT_VALID */]: "Element style state '{0}' is not a valid element style state",
    ["VALIDATOR_ELEMENT_OR_STYLE_STATE_NOT_VALID" /* VALIDATOR_ELEMENT_OR_STYLE_STATE_NOT_VALID */]: "Element or style state '{0}' is not a valid element or style state",
    ["VALIDATOR_ATTRIBUTE_RESERVED_VALUE_NOT_VALID" /* VALIDATOR_ATTRIBUTE_RESERVED_VALUE_NOT_VALID */]: "Attribute value '{0}' is not a valid value for attribute '{1}' in element '{2}'",
    ["VALIDATOR_ATTRIBUTE_NOT_VALID" /* VALIDATOR_ATTRIBUTE_NOT_VALID */]: "Attribute '{0}' is not a valid attribute for element '{1}'",
    ["VALIDATOR_STYLE_ATTRIBUTE_NOT_VALID" /* VALIDATOR_STYLE_ATTRIBUTE_NOT_VALID */]: "Style attribute '{0}' is not valid for element '{1}'",
    ["VALIDATOR_ATTRIBUTE_VALUE_NOT_VALID" /* VALIDATOR_ATTRIBUTE_VALUE_NOT_VALID */]: "Attribute value '{0}' is not a valid {1} for attribute '{2}' in element '{3}",
    ["VALIDATOR_ATTRIBUTE_VALUE_NOT_EMPTY" /* VALIDATOR_ATTRIBUTE_VALUE_NOT_EMPTY */]: "Attribute value '{0}' is a empty value for attribute '{1} as it should not be empty in element '{2}",
    ["VALIDATOR_ATTRIBUTE_NOT_SUPPORTED" /* VALIDATOR_ATTRIBUTE_NOT_SUPPORTED */]: "Attribute '{0}' is not supported for element '{1}'",
    ["VALIDATOR_SAVE_OUTPUT_ERROR" /* VALIDATOR_SAVE_OUTPUT_ERROR */]: "Error saving tree in '{0} - {1}"
  };

  // common/message/validator/message.ts
  var validatorMessages = {
    ["English" /* LanguageEnglish */]: enMessages3,
    ["Persian" /* LanguagePersian */]: faMessages3
  };

  // common/message/generator/fa.ts
  var faMessages4 = {
    ["GENERATOR_PREFIX" /* GENERATOR_PREFIX */]: "\u062E\u0637\u0627\u06CC \u062A\u0648\u0644\u06CC\u062F \u06A9\u0646\u0646\u062F\u0647: ",
    ["GENERATOR_CANNOT_OUTDENT_BELOW_ZERO" /* GENERATOR_CANNOT_OUTDENT_BELOW_ZERO */]: "\u0646\u0645\u06CC\u200C\u062A\u0648\u0627\u0646\u06CC\u062F \u0627\u0632 \u0635\u0641\u0631 \u06A9\u0645\u062A\u0631 \u0628\u0631\u0648\u062F",
    ["GENERATOR_UNKNOWN_ELEMENT_TYPE" /* GENERATOR_UNKNOWN_ELEMENT_TYPE */]: "\u0646\u0648\u0639 \u0639\u0646\u0635\u0631 \u0646\u0627\u0634\u0646\u0627\u062E\u062A\u0647: {0}",
    ["GENERATOR_INCLUDE_FILE_NOT_FOUND" /* GENERATOR_INCLUDE_FILE_NOT_FOUND */]: '\u0641\u0627\u06CC\u0644 \u062F\u0631 \u062F\u0633\u062A\u0648\u0631 \u0641\u0631\u0627\u062E\u0648\u0627\u0646\u06CC \u06CC\u0627\u0641\u062A \u0646\u0634\u062F - "{0}"',
    ["GENERATOR_INCLUDE_FILE_READ_ERROR" /* GENERATOR_INCLUDE_FILE_READ_ERROR */]: '\u062E\u0637\u0627 \u062F\u0631 \u062E\u0648\u0627\u0646\u062F\u0646 \u0641\u0627\u06CC\u0644 \u062F\u0631 \u062F\u0633\u062A\u0648\u0631 \u0641\u0631\u0627\u062E\u0648\u0627\u0646\u06CC - "{0}"',
    ["GENERATOR_INCLUDE_FILE_PATH_NOT_PROVIDED" /* GENERATOR_INCLUDE_FILE_PATH_NOT_PROVIDED */]: "\u0645\u0633\u06CC\u0631 \u0641\u0627\u06CC\u0644 \u062F\u0631 \u062F\u0633\u062A\u0648\u0631 \u0641\u0631\u0627\u062E\u0648\u0627\u0646\u06CC \u0627\u0631\u0627\u0626\u0647 \u0646\u0634\u062F\u0647 \u0627\u0633\u062A",
    ["GENERATOR_INCLUDE_HTTP_ERROR_HTTP_STATUS" /* GENERATOR_INCLUDE_HTTP_ERROR_HTTP_STATUS */]: '\u062E\u0637\u0627 \u062F\u0631 \u0641\u0631\u0627\u062E\u0648\u0627\u0646\u06CC \u0627\u0632 \u0646\u0634\u0627\u0646\u06CC \u0627\u06CC\u0646\u062A\u0631\u0646\u062A\u06CC - "{0}" - \u06A9\u062F \u0648\u0636\u0639\u06CC\u062A HTTP: {1}',
    ["GENERATOR_INCLUDE_HTTP_ERROR" /* GENERATOR_INCLUDE_HTTP_ERROR */]: '\u062E\u0637\u0627 \u062F\u0631 \u0641\u0631\u0627\u062E\u0648\u0627\u0646\u06CC \u0627\u0632 \u0646\u0634\u0627\u0646\u06CC \u0627\u06CC\u0646\u062A\u0631\u0646\u062A\u06CC - "{0}"',
    ["GENERATOR_SAVE_OUTPUT_ERROR" /* GENERATOR_SAVE_OUTPUT_ERROR */]: "\u062E\u0637\u0627 \u062F\u0631 \u0630\u062E\u06CC\u0631\u0647 \u062E\u0631\u0648\u062C\u06CC \u062F\u0631 '{0}' - {1}"
  };

  // common/message/generator/en.ts
  var enMessages4 = {
    ["GENERATOR_PREFIX" /* GENERATOR_PREFIX */]: "Generator error: ",
    ["GENERATOR_CANNOT_OUTDENT_BELOW_ZERO" /* GENERATOR_CANNOT_OUTDENT_BELOW_ZERO */]: "Cannot outdent below 0",
    ["GENERATOR_UNKNOWN_ELEMENT_TYPE" /* GENERATOR_UNKNOWN_ELEMENT_TYPE */]: "Unknown element type: {0}",
    ["GENERATOR_INCLUDE_FILE_NOT_FOUND" /* GENERATOR_INCLUDE_FILE_NOT_FOUND */]: 'File not found in include command - "{0}"',
    ["GENERATOR_INCLUDE_FILE_READ_ERROR" /* GENERATOR_INCLUDE_FILE_READ_ERROR */]: 'Error reading file in include command - "{0}"',
    ["GENERATOR_INCLUDE_FILE_PATH_NOT_PROVIDED" /* GENERATOR_INCLUDE_FILE_PATH_NOT_PROVIDED */]: "File path not provided in include command",
    ["GENERATOR_INCLUDE_HTTP_ERROR_HTTP_STATUS" /* GENERATOR_INCLUDE_HTTP_ERROR_HTTP_STATUS */]: 'Error in including from internet address - "{0}" - HTTP status code: {1}',
    ["GENERATOR_INCLUDE_HTTP_ERROR" /* GENERATOR_INCLUDE_HTTP_ERROR */]: 'Error in including from internet address - "{0}"',
    ["GENERATOR_SAVE_OUTPUT_ERROR" /* GENERATOR_SAVE_OUTPUT_ERROR */]: "Error saving output in '{0}' - {1}"
  };

  // common/message/generator/message.ts
  var generatorMessages = {
    ["English" /* LanguageEnglish */]: enMessages4,
    ["Persian" /* LanguagePersian */]: faMessages4
  };

  // common/message/message.ts
  function messageRenderer(type, messages, language, messageKey, ...args) {
    const prefix = getMessagePrefix(type, language, messages);
    const messageTemplate = messages[language]?.[messageKey];
    if (!messageTemplate) {
      throw new Error(
        `Message key "${String(messageKey)}" not found for type "${type}" in language "${language}".`
      );
    }
    return prefix + messageTemplate.replace(/{(\d+)}/g, (_, index) => args[index] || `{${index}}`);
  }
  function getMessagePrefix(type, language, messages) {
    const prefixKey = `${type}_PREFIX`;
    return messages[language]?.[prefixKey] || "";
  }
  function lexerMessageRenderer(language, messageKey, ...args) {
    return messageRenderer("LEXER", lexerMessages, language, messageKey, ...args);
  }
  function parserMessageRenderer(language, messageKey, ...args) {
    return messageRenderer("PARSER", parserMessages, language, messageKey, ...args);
  }
  function validatorMessageRenderer(language, messageKey, ...args) {
    return messageRenderer("VALIDATOR", validatorMessages, language, messageKey, ...args);
  }
  function generatorMessageRenderer(language, messageKey, ...args) {
    return messageRenderer("GENERATOR", generatorMessages, language, messageKey, ...args);
  }

  // phase/lexer/lex/comment/multi.ts
  function lexerLexReadBlockComment(lexer) {
    lexer.advance();
    lexer.advance();
    let blockCommentDepth = 1;
    while (lexer.currentChar !== "\0" && blockCommentDepth > 0) {
      if (lexer.currentChar === "/" && lexer.nextChar === "*") {
        blockCommentDepth++;
        lexer.advance();
      } else if (lexer.currentChar === "*" && lexer.nextChar === "/") {
        blockCommentDepth--;
        lexer.advance();
      }
      lexer.advance();
    }
    if (blockCommentDepth > 0) {
      lexer.pushError(lexerMessageRenderer(lexer.language.id, "LEXER_UNTERMINATED_MULTI_LINE_COMMENT_BLOCK" /* LEXER_UNTERMINATED_MULTI_LINE_COMMENT_BLOCK */));
    }
  }

  // phase/lexer/tokenizer/operator.ts
  var operatorTypeMaps = {
    "?": "TOKEN_QUESTION" /* TOKEN_QUESTION */,
    "!=": "NOT_EQUAL" /* TOKEN_NOT_EQUAL */,
    "==": "EQUAL" /* TOKEN_EQUAL */,
    "===": "EQUAL" /* TOKEN_EQUAL */,
    "&&": "AND_AND" /* TOKEN_AND_AND */,
    "||": "OR_OR" /* TOKEN_OR_OR */,
    "<=": "LESS_EQUAL" /* TOKEN_LESS_EQUAL */,
    ">=": "GREATER_EQUAL" /* TOKEN_GREATER_EQUAL */,
    "++": "INCREMENT" /* TOKEN_INCREMENT */,
    "\uFF0B\uFF0B": "INCREMENT" /* TOKEN_INCREMENT */,
    "\uFE62\uFE62": "INCREMENT" /* TOKEN_INCREMENT */,
    "--": "DECREMENT" /* TOKEN_DECREMENT */,
    "\u2212\u2212": "DECREMENT" /* TOKEN_DECREMENT */,
    "<<": "SHIFT_LEFT" /* TOKEN_SHIFT_LEFT */,
    ">>": "SHIFT_RIGHT" /* TOKEN_SHIFT_RIGHT */,
    ">>=": "SHIFT_RIGHT_ASSIGN" /* TOKEN_SHIFT_RIGHT_ASSIGN */,
    "<<=": "SHIFT_LEFT_ASSIGN" /* TOKEN_SHIFT_LEFT_ASSIGN */,
    "{": "LEFT_BRACE" /* TOKEN_LEFT_BRACE */,
    "}": "RIGHT_BRACE" /* TOKEN_RIGHT_BRACE */,
    "[": "LEFT_BRACKET" /* TOKEN_LEFT_BRACKET */,
    "]": "RIGHT_BRACKET" /* TOKEN_RIGHT_BRACKET */,
    ":": "COLON" /* TOKEN_COLON */,
    "::": "COLON_COLON" /* TOKEN_COLON_COLON */,
    ",": "COMMA" /* TOKEN_COMMA */,
    "(": "LEFT_PAREN" /* TOKEN_LEFT_PAREN */,
    ")": "RIGHT_PAREN" /* TOKEN_RIGHT_PAREN */,
    "+": "PLUS" /* TOKEN_PLUS */,
    "\uFE62": "PLUS" /* TOKEN_PLUS */,
    "\uFF0B": "PLUS" /* TOKEN_PLUS */,
    "-": "MINUS" /* TOKEN_MINUS */,
    "\u2212": "MINUS" /* TOKEN_MINUS */,
    "->": "TOKEN_MEMBER_POINTER" /* TOKEN_MEMBER_POINTER */,
    "\u2212>": "TOKEN_MEMBER_POINTER" /* TOKEN_MEMBER_POINTER */,
    ".": "MEMBER" /* TOKEN_MEMBER */,
    "..": "RANGE" /* TOKEN_RANGE */,
    "*": "MULTIPLY" /* TOKEN_MULTIPLY */,
    "\xD7": "MULTIPLY" /* TOKEN_MULTIPLY */,
    "/": "DIVIDE" /* TOKEN_DIVIDE */,
    // "//": TokenOperatorType.TOKEN_DIVIDE_INT,
    "\xF7": "DIVIDE" /* TOKEN_DIVIDE */,
    // "": TokenOperatorType.TOKEN_DIVIDE_INT,
    "%": "MOD" /* TOKEN_MODULO */,
    "**": "POWER" /* TOKEN_POWER */,
    "\xD7\xD7": "POWER" /* TOKEN_POWER */,
    "=": "ASSIGN" /* TOKEN_ASSIGN */,
    "\u2A75": "EQUAL" /* TOKEN_EQUAL */,
    "<": "LESS" /* TOKEN_LESS */,
    ">": "GREATER" /* TOKEN_GREATER */,
    "!": "NOT" /* TOKEN_NOT */,
    "&": "AND_BIT" /* TOKEN_AND_BIT */,
    "|": "OR_BIT" /* TOKEN_OR_BIT */,
    "^": "XOR_BIT" /* TOKEN_XOR_BIT */,
    "~": "XOR_BIT" /* TOKEN_XOR_BIT */
  };
  function isOperator(type) {
    return Object.values(TokenOperatorType).includes(type);
  }
  var invalidOperators = [
    "RIGHT_PAREN" /* TOKEN_RIGHT_PAREN */,
    "RIGHT_BRACE" /* TOKEN_RIGHT_BRACE */,
    "RIGHT_BRACKET" /* TOKEN_RIGHT_BRACKET */
  ];

  // phase/lexer/lex/lex.ts
  function lex(lexer) {
    while (lexer.index < lexer.source.length) {
      const char = lexer.currentChar;
      switch (char) {
        // End of file
        case "\0":
          lexer.advance();
          break;
        // New line
        case "\n":
          lexer.line++;
          lexer.column = 0;
          lexer.advance();
          break;
        // Whitespace
        case "\b":
        // Backspace
        case "\f":
        // Form feed
        case "\r":
        // Carriage return
        case "	":
        // Horizontal tab
        case "\v":
        // Vertical tab
        case " ":
          lexer.advance();
          break;
        case "+":
        case "\uFE62":
        case "\uFF0B":
          lexer.readDoubleToken(char);
          break;
        case "-":
        case "\u2212":
          if (lexer.nextChar === ">") {
            const nextChar = lexer.nextChar;
            lexer.advance();
            lexer.advance();
            lexer.pushToken(new Token(operatorTypeMaps[char + nextChar], lexer.getLocation(), char + ">", void 0));
          } else {
            lexer.readDoubleToken(char);
          }
          break;
        case "*":
        case "\xD7":
          lexer.readDoubleToken(char);
          break;
        case "/":
        case "\xF7":
          if (lexer.nextChar === "/") {
            lexerLexReadComment(lexer);
          } else if (lexer.nextChar === "*") {
            lexerLexReadBlockComment(lexer);
          } else {
            lexer.advance();
            lexer.pushToken(new Token(operatorTypeMaps[char], lexer.getLocation(), char, void 0));
          }
          break;
        case "&":
          lexer.readDoubleToken(char);
          break;
        case "|":
          lexer.readDoubleToken(char);
          break;
        case ":":
          lexer.readDoubleToken(char);
          break;
        case ".":
          lexer.readDoubleToken(char);
          break;
        case "=":
          lexer.readThreeToken(char, char);
          break;
        case "<":
          lexer.readThreeOrToken(char, "=");
          break;
        case ">":
          lexer.readThreeOrToken(char, "=");
          break;
        case "~":
        case "{":
        case "}":
        case "[":
        case "]":
        case ",":
        case "(":
        case ")":
        case "%":
        case "^":
        case "?":
        case "!":
        case "\u2A75":
          lexer.pushToken(new Token(operatorTypeMaps[char], lexer.getLocation(), char, void 0));
          lexer.advance();
          break;
        default:
          if (stringOpenings.includes(char)) {
            lexerLexString(lexer, char);
          } else if (isUtf8Number(char)) {
            lexerLexNumber(lexer);
          } else if (isUtf8Alpha(char)) {
            lexerLexIdentifier(lexer);
          } else {
            lexer.pushError(lexerMessageRenderer(lexer.language.id, "LEXER_INVALID_UNEXPECTED_CHAR" /* LEXER_INVALID_UNEXPECTED_CHAR */, `${char}`));
            lexer.advance();
          }
      }
    }
    lexer.pushToken(new Token("EOF" /* TOKEN_EOF */, lexer.getLocation(), void 0, void 0));
  }

  // phase/lexer/tokenizer/location.ts
  var TokenLocation = class {
    constructor(index, length, startLine, startColumn, endLine, endColumn) {
      this.index = index;
      this.length = length;
      this.startLine = startLine;
      this.startColumn = startColumn;
      this.endLine = endLine;
      this.endColumn = endColumn;
    }
    stringify(wantsJson = true) {
      const obj = {
        index: this.index,
        length: this.length,
        start: { line: this.startLine, column: this.startColumn },
        end: { line: this.endLine, column: this.endColumn }
      };
      return stringify(obj, wantsJson);
    }
  };

  // phase/lexer/lex/lexer.ts
  var Lexer = class {
    constructor(source, selectedLanguage, fileName, absoluteDirPath) {
      this.source = source;
      this.index = 0;
      this.line = 1;
      this.column = 0;
      this.tokens = [];
      this.language = selectedLanguage;
      this.fileName = fileName;
      this.absoluteDirPath = absoluteDirPath;
    }
    get currentChar() {
      return this.source[this.index] || "\0";
    }
    get previousChar() {
      return this.source[this.index - 1] || "\0";
    }
    get nextChar() {
      return this.source[this.index + 1] || "\0";
    }
    advance() {
      this.index++;
      this.column++;
    }
    retreat() {
      this.index--;
      this.column--;
    }
    pushError(message) {
      const tokenData = new TokenData(2 /* TOKEN_DATA_TYPE_STRING */, message);
      const token = new Token("ERROR" /* TOKEN_ERROR */, this.getLocation(), void 0, tokenData);
      this.pushToken(token);
    }
    pushToken(token) {
      this.tokens.push(token);
    }
    getLocation() {
      return new TokenLocation(
        this.index,
        1,
        this.line,
        this.column,
        this.line,
        this.column + 1
      );
    }
    readDoubleToken(char) {
      const nextChar = this.nextChar;
      if (nextChar === char) {
        this.advance();
        this.advance();
        const token = new Token(operatorTypeMaps[char + char], this.getLocation(), char + char, void 0);
        this.pushToken(token);
      } else {
        this.advance();
        const token = new Token(operatorTypeMaps[char], this.getLocation(), char, void 0);
        this.pushToken(token);
      }
    }
    readThreeOrToken(char, char2) {
      const nextChar = this.nextChar;
      if (nextChar === char2) {
        this.advance();
        this.advance();
        const token = new Token(operatorTypeMaps[char + char2], this.getLocation(), char + char2, void 0);
        this.pushToken(token);
      } else if (nextChar === char) {
        this.advance();
        this.advance();
        if (this.nextChar === char2) {
          this.advance();
          const token = new Token(operatorTypeMaps[char + char + char2], this.getLocation(), char + char + char2, void 0);
          this.pushToken(token);
        } else {
          const token = new Token(operatorTypeMaps[char + char], this.getLocation(), char + char, void 0);
          this.pushToken(token);
        }
      } else {
        this.advance();
        const token = new Token(operatorTypeMaps[char], this.getLocation(), char, void 0);
        this.pushToken(token);
      }
    }
    readThreeToken(char, char2) {
      const nextChar = this.nextChar;
      if (nextChar === char2) {
        this.advance();
        this.advance();
        const token = new Token(operatorTypeMaps[char + char2], this.getLocation(), char + char2, void 0);
        this.pushToken(token);
      } else if (nextChar === char) {
        this.advance();
        this.advance();
        const token = new Token(operatorTypeMaps[char + char], this.getLocation(), char + char, void 0);
        this.pushToken(token);
      } else {
        this.advance();
        const token = new Token(operatorTypeMaps[char], this.getLocation(), char, void 0);
        this.pushToken(token);
      }
    }
    stringify(wantsJson = true) {
      const jsonArray = this.tokens.map((token) => token.stringify(false));
      return stringify(jsonArray, wantsJson);
    }
  };

  // common/cli/run/lexer.ts
  function processCommandRunLexer(fileName, absoluteDirPath, source, selectedLanguage) {
    const lexer = new Lexer(source, selectedLanguage, fileName, absoluteDirPath);
    lex(lexer);
    if (typeof window === "undefined") {
      console.log(lexer.stringify());
    } else {
      window.lexer = lexer;
    }
    return 0;
  }

  // common/cli/check-error.ts
  function checkError(parser, validator, generator) {
    if (parser) {
      if (parser.ast.errors.length > 0) {
        parser.ast.errors.forEach((error) => {
          console.error(error);
        });
        return false;
      }
    }
    if (validator !== void 0) {
      if (validator.errors.length > 0) {
        validator.errors.forEach((error) => {
          console.error(error);
        });
        return false;
      }
    }
    if (generator !== void 0) {
      if (generator.errors.length > 0) {
        generator.errors.forEach((error) => {
          console.error(error);
        });
        return false;
      }
    }
    return true;
  }

  // phase/parser/parse/ast/node.ts
  var AstNode = class {
    constructor(type) {
      this.type = type;
    }
    stringify(wantsJson = true) {
      const obj = {
        type: this.type
      };
      return stringify(obj, wantsJson);
    }
  };

  // phase/parser/parse/ast/layout/layout.ts
  var AstLayout = class extends AstNode {
    constructor(root) {
      super("Layout");
      this.root = root;
    }
    stringify(wantsJson = true) {
      const obj = {
        root: this.root.stringify(false)
      };
      return stringify(obj, wantsJson);
    }
  };

  // phase/parser/parse/layout/key.ts
  function parserParseLayoutKey(parser) {
    const token = parser.currentToken;
    const key_tokens = [];
    if (token.isKeyword) {
      key_tokens.push(token);
      parser.next();
      if (!parser.isEnd) {
        while (true) {
          const ntoken = parser.currentToken;
          if (!ntoken.isKeyword || parser.isEnd) {
            break;
          }
          key_tokens.push(ntoken);
          parser.next();
        }
        ;
      }
    }
    return key_tokens;
  }

  // phase/parser/parse/ast/layout/block.ts
  var AstLayoutBlock = class extends AstNode {
    constructor() {
      super("LayoutBlock");
      this.items = [];
    }
    get length() {
      return this.items.length;
    }
    push(element) {
      this.items.push(element);
      return true;
    }
    stringify(wantsJson = true) {
      const obj = {
        items: this.items.map((item) => item.stringify(false))
      };
      return stringify(obj, wantsJson);
    }
  };

  // phase/parser/parse/ast/layout/attributes.ts
  var AstLayoutAttributes = class extends AstNode {
    constructor() {
      super("LayoutAttributes");
      this.items = [];
    }
    get length() {
      return this.items.length;
    }
    getByGenerateName(generate_name) {
      for (let attr of this.items) {
        if (attr.generate_name === generate_name) {
          return attr;
        }
      }
      return void 0;
    }
    exists(attribute) {
      for (let attr of this.items) {
        if (attr.getCheckSum() === attribute.getCheckSum()) {
          return true;
        }
      }
      return false;
    }
    styleExists(attribute) {
      for (let attr of this.items) {
        if (attr.isStyle() && attr.getCheckSum() === attribute.getCheckSum()) {
          return true;
        }
      }
      return false;
    }
    normalExists(attribute) {
      for (let attr of this.items) {
        if (attr.isNormal() && attr.getCheckSum() === attribute.getCheckSum()) {
          return true;
        }
      }
      return false;
    }
    push(attribute) {
      if (this.exists(attribute)) {
        return false;
      } else {
        this.items.push(attribute);
        return true;
      }
    }
    stringify(wantsJson = true) {
      const obj = {
        items: this.items.map((item) => item.stringify(false))
      };
      return stringify(obj, wantsJson);
    }
  };

  // common/identifier-generator.ts
  var IdentifierGenerator = class {
    static current = "a";
    static init() {
      this.current = "a";
    }
    static get() {
      const identifier = this.current;
      const currentLength = this.current.length;
      for (let i = currentLength - 1; i >= 0; i--) {
        if (this.current[i] < "z") {
          this.current = this.updateCurrentIdentifier(i);
          return identifier;
        }
        this.current = this.resetCharacterAtIndex(i);
        if (i === 0) {
          this.current = "a" + this.current;
        }
      }
      return identifier;
    }
    static updateCurrentIdentifier(index) {
      const updatedChar = String.fromCharCode(this.current.charCodeAt(index) + 1);
      return this.current.slice(0, index) + updatedChar + this.current.slice(index + 1);
    }
    static resetCharacterAtIndex(index) {
      return this.current.slice(0, index) + "a" + this.current.slice(index + 1);
    }
  };

  // phase/parser/parse/ast/layout/element.ts
  var AstLayoutElement = class extends AstNode {
    constructor(enduser_name) {
      super("LayoutElement");
      this.enduser_name = enduser_name;
      this.block = new AstLayoutBlock();
      this.attributes = new AstLayoutAttributes();
      this.styles = new AstLayoutAttributes();
      this.parent_generate_name = void 0;
      this.parent_generate_type = void 0;
      this.generate_name = void 0;
      this.generate_type = void 0;
      this.content = void 0;
      this.repeat = 1;
      this.kind = "NormalElement" /* NormalElement */;
      this.built_in_selector = void 0;
    }
    isStyleElement() {
      if (this.generate_type === void 0) {
        return false;
      }
      return this.generate_type.startsWith("RuntimeStyleElement");
    }
    isStateStyle() {
      return this.kind === "StyleState" /* StyleState */;
    }
    generateBuiltInSelector(validator) {
      this.built_in_selector = "." + IdentifierGenerator.get();
    }
    stringify(wantsJson = true) {
      const obj = {
        kind: this.kind,
        built_in_selector: this.built_in_selector,
        enduser_name: this.enduser_name,
        generate_name: this.generate_name,
        generate_type: this.generate_type,
        block: this.block.stringify(false),
        attributes: this.attributes.stringify(false),
        styles: this.styles.stringify(false),
        repeat: this.repeat
      };
      return stringify(obj, wantsJson);
    }
  };

  // phase/parser/parse/ast/layout/attribute.ts
  var AstLayoutAttribute = class extends AstNode {
    constructor(element_enduser_name, key, value, kind, output_type = "Normal" /* Normal */) {
      super("LayoutAttribute");
      this.generate_name = void 0;
      this.generate_value = void 0;
      this.generate_type = void 0;
      this.key = key;
      this.value = value;
      this.kind = kind;
      this.enduser_name = key;
      this.element_enduser_name = element_enduser_name;
      this.output_type = output_type;
      this.is_hide = false;
    }
    getValue() {
      if (this.generate_value !== void 0) {
        return this.generate_value;
      }
      return this.value.getString();
    }
    isStyle() {
      return this.kind === "Style" /* Style */;
    }
    isNormal() {
      return this.kind === "Normal" /* Normal */;
    }
    getCheckSum() {
      return this.key;
    }
    stringify(wantsJson = true) {
      const obj = {
        key: this.key,
        value: this.value.stringify(false),
        kind: this.kind,
        enduser_name: this.enduser_name,
        generate_name: this.generate_name,
        generate_type: this.generate_type,
        generate_value: this.generate_value
      };
      return stringify(obj, wantsJson);
    }
  };

  // phase/parser/parse/expression/precedence.ts
  function LeftAssociative(priority) {
    return { left_power: priority - 1, right_power: priority };
  }
  function RightAssociative(priority) {
    return { left_power: priority + 1, right_power: priority };
  }
  function bp_lookup(whichOperator) {
    const no_binding_power = { left_power: 0, right_power: 0 };
    switch (whichOperator) {
      case "PLUS" /* TOKEN_PLUS */:
        return LeftAssociative(100);
      case "MINUS" /* TOKEN_MINUS */:
        return LeftAssociative(100);
      case "MULTIPLY" /* TOKEN_MULTIPLY */:
        return LeftAssociative(200);
      case "DIVIDE" /* TOKEN_DIVIDE */:
        return LeftAssociative(200);
      case "POWER" /* TOKEN_POWER */:
        return RightAssociative(99);
      case "TOKEN_QUESTION" /* TOKEN_QUESTION */:
        return RightAssociative(1e3);
      case "GREATER" /* TOKEN_GREATER */:
        return LeftAssociative(50);
      case "GREATER_EQUAL" /* TOKEN_GREATER_EQUAL */:
        return LeftAssociative(50);
      case "LESS" /* TOKEN_LESS */:
        return LeftAssociative(50);
      case "LESS_EQUAL" /* TOKEN_LESS_EQUAL */:
        return LeftAssociative(50);
      case "EQUAL" /* TOKEN_EQUAL */:
        return LeftAssociative(50);
      case "NOT_EQUAL" /* TOKEN_NOT_EQUAL */:
        return LeftAssociative(50);
      // --- Postfix --- (Always Right Associative)
      case "NOT" /* TOKEN_NOT */:
        return RightAssociative(400);
      case "MEMBER" /* TOKEN_MEMBER */:
        return RightAssociative(800);
      //Note: Postfix operators are always RightAssociative
      case "LEFT_PAREN" /* TOKEN_LEFT_PAREN */:
        return RightAssociative(400);
      default:
        return no_binding_power;
    }
  }
  function prefix_bp_lookup(whichOperator) {
    switch (whichOperator) {
      case "NOT" /* TOKEN_NOT */:
        return 300;
      case "PLUS" /* TOKEN_PLUS */:
        return 300;
      case "MINUS" /* TOKEN_MINUS */:
        return 300;
      // case TokenOperatorType.TOKEN_LEFT_PAREN: return 900;
      default:
        return 0;
    }
  }

  // phase/parser/parse/ast/expression/expression.ts
  var AstExpression = class extends AstNode {
    constructor(type) {
      super(type);
    }
    getString() {
      if (this.generated_value === void 0) {
        return "";
      }
      return this.generated_value;
    }
  };

  // phase/parser/parse/ast/expression/binary.ts
  var AstExpressionBinary = class extends AstExpression {
    constructor(left, operator, right) {
      super("ExpressionBinary");
      this.left = left;
      this.operator = operator;
      this.right = right;
      this.value_type = void 0;
    }
    getString() {
      if (this.generated_value === void 0) {
        return `${this.left.getString()} ${this.operator} ${this.right.getString()}`;
      }
      return this.generated_value;
    }
    stringify(wantsJson = true) {
      const obj = {
        type: "ExpressionBinary",
        operator: this.operator,
        left: this.left.stringify(false),
        right: this.right.stringify(false)
      };
      return stringify(obj, wantsJson);
    }
  };

  // phase/parser/parse/expression/binary.ts
  function parseExpressionBinary(parser, left, min_bp) {
    const operator = parser.currentToken;
    const isOp = operator && isOperator(operator.type);
    const isInvalidOp = isOp && invalidOperators.includes(operator.type);
    if (!operator || !isOp || isInvalidOp) {
      return void 0;
    }
    parser.next();
    const right = parseExpression(parser, min_bp);
    if (!right) {
      parser.pushError(parserMessageRenderer(parser.getLanguageId(), "PARSER_EXPRESSION_EXPECTED_AFTER_OPERATOR" /* PARSER_EXPRESSION_EXPECTED_AFTER_OPERATOR */, operator.enduser));
      return void 0;
    }
    const ast = new AstExpressionBinary(left, operator.type, right);
    return ast;
  }

  // phase/parser/parse/ast/expression/prefix.ts
  var AstExpressionPrefix = class extends AstExpression {
    constructor(operator, right) {
      super("ExpressionPostfix");
      this.operator = operator;
      this.right = right;
      this.value_type = void 0;
    }
    getString() {
      return `${this.operator}${this.right.getString()}`;
    }
    stringify(wantsJson = true) {
      const obj = {
        type: "ExpressionPostfix",
        operator: this.operator,
        right: this.right.stringify(false)
      };
      return stringify(obj, wantsJson);
    }
  };

  // phase/parser/parse/expression/prefix.ts
  function parseExpressionPrefix(parser, min_bp) {
    const op = parser.currentToken;
    if (op.type !== "PLUS" /* TOKEN_PLUS */ && op.type !== "MINUS" /* TOKEN_MINUS */) {
      parser.pushError("Expected prefix operator but got '" + op.enduser_token + "'");
      return void 0;
    }
    parser.next();
    const right = parseExpression(parser, min_bp);
    if (right === void 0) {
      parser.pushError("Expected expression after prefix operator but is not valid");
      return void 0;
    }
    const ast = new AstExpressionPrefix(op.type, right);
    return ast;
  }

  // phase/parser/parse/ast/expression/variable.ts
  var AstExpressionVariable = class extends AstExpression {
    constructor(left) {
      super("ExpressionVariable");
      this.left = left;
      this.value_type = void 0;
    }
    getString() {
      return this.left.getString();
    }
    stringify(wantsJson = true) {
      const obj = {
        type: "ExpressionVariable",
        left: this.left.stringify(false)
      };
      return stringify(obj, wantsJson);
    }
  };

  // phase/parser/parse/ast/expression/literal.ts
  var AstExpressionLiteral = class extends AstExpression {
    constructor(value, type) {
      super("ExpressionLiteral");
      this.value_type = type;
      this.value = value;
    }
    getString() {
      return this.value;
    }
    stringify(wantsJson = true) {
      const obj = {
        type: "ExpressionLiteral",
        value_type: this.type,
        value: this.value
      };
      return stringify(obj, wantsJson);
    }
  };

  // phase/parser/parse/ast/expression/type.ts
  var AstType = class _AstType extends AstNode {
    constructor(type_kind) {
      super("Type");
      this.is_system = false;
      this.is_primitive = false;
      this.type_kind = type_kind;
      this.is_pointer = false;
      this.is_reference = false;
      this.is_array = false;
      this.members = [];
      this.func_name = void 0;
      this.func_generated_name = void 0;
      this.func_args = [];
      this.func_return_type = void 0;
    }
    getType() {
      if (this.isFunction && this.func_return_type) {
        return this.func_return_type;
      }
      return this;
    }
    getKindType() {
      if (this.isFunction && this.func_return_type) {
        return this.func_return_type?.getKindType();
      }
      return this.type_kind;
    }
    setPrimitive() {
      this.is_primitive = true;
      return this;
    }
    setSyetem() {
      this.is_system = true;
      return this;
    }
    addMember(item) {
      if (this.isPackage === false) {
        return false;
      }
      this.members.push(item);
      return true;
    }
    getMember(name) {
      if (this.isPackage === false && this.isStruct === false) {
        return void 0;
      }
      for (const member of this.members) {
        if (member.func_name === name || member.member_name === name) {
          return member;
        }
      }
      return void 0;
    }
    get isFunction() {
      return this.type_kind === "function";
    }
    get isIdentifier() {
      return this.type_kind === "identifier";
    }
    get isPackage() {
      return this.type_kind === "package";
    }
    get isString() {
      return this.type_kind === "string";
    }
    get isNumber() {
      return this.isFloat || this.isInt;
    }
    get isFloat() {
      return this.type_kind === "float";
    }
    get isInt() {
      return this.type_kind === "int";
    }
    get isStruct() {
      return this.type_kind === "struct";
    }
    getString() {
      return this.type_kind;
    }
    stringify(wantsJson = true) {
      const obj = {
        type: "Type",
        type_kind: this.type_kind
      };
      return stringify(obj, wantsJson);
    }
    static createPointer() {
      return new _AstType("pointer");
    }
    static createFunction(name, generated_name, args, return_type) {
      const type = new _AstType("function");
      type.func_name = name;
      type.func_generated_name = generated_name;
      type.func_args = args;
      type.func_return_type = return_type;
      return type;
    }
    static createPackage() {
      return new _AstType("package");
    }
    static createMemberValue(name, type) {
      type.member_name = name;
      return type;
    }
    static createIdentifier() {
      return new _AstType("identifier");
    }
    static createString() {
      return new _AstType("string");
    }
    static createBool() {
      return new _AstType("bool");
    }
    static createFloat() {
      return new _AstType("float");
    }
    static createSize() {
      return new _AstType("size");
    }
    static createInt() {
      return new _AstType("int");
    }
    static createVoid() {
      return new _AstType("void");
    }
    isEqual(type) {
      return this.type_kind === type.type_kind;
    }
    castablle(type) {
      if (type.type_kind === "string" && this.type_kind === "pointer") {
        return true;
      }
      return this.isEqual(type);
    }
  };

  // phase/parser/parse/expression/literal.ts
  function parseExpressionLiteral(parser) {
    const currentToken = parser.currentToken;
    if (currentToken?.data !== void 0) {
      parser.next();
      switch (currentToken.type) {
        case "IDENTIFIER" /* TOKEN_IDENTIFIER */:
          const varable_identifier = new AstExpressionLiteral(currentToken.data.getValueString(), AstType.createIdentifier());
          return new AstExpressionVariable(varable_identifier);
        case "STRING" /* TOKEN_STRING */:
          return new AstExpressionLiteral(currentToken.data.getValueString(), AstType.createString().setPrimitive());
        case "BOOL_FALSE" /* TOKEN_BOOL_FALSE */:
          return new AstExpressionLiteral("TRUE", AstType.createBool().setPrimitive());
        case "BOOL_TRUE" /* TOKEN_BOOL_TRUE */:
          return new AstExpressionLiteral("TRUE", AstType.createBool().setPrimitive());
        case "NUMBER_FLOAT" /* TOKEN_NUMBER_FLOAT */:
          return new AstExpressionLiteral(currentToken.data.getValueString(), AstType.createFloat().setPrimitive());
        case "NUMBER_INT" /* TOKEN_NUMBER_INT */:
          return new AstExpressionLiteral(currentToken.data.getValueString(), AstType.createInt().setPrimitive());
      }
    }
    return void 0;
  }

  // phase/parser/parse/expression/parenthese.ts
  function parseExpressionParentheses(parser) {
    const expr = parseExpression(parser);
    parser.expect("RIGHT_PAREN" /* TOKEN_RIGHT_PAREN */);
    return expr;
  }

  // phase/parser/parse/expression/primary.ts
  function parseExpressionPrimary(parser) {
    const currentToken = parser.currentToken;
    const isOp = currentToken && isOperator(currentToken.type);
    const isInvalidOp = isOp && invalidOperators.includes(currentToken.type);
    if (!currentToken || isInvalidOp) {
      parser.pushError("Invalid operator inside primary expression " + currentToken.enduser_token);
      return void 0;
    } else if (parser.skip("LEFT_PAREN" /* TOKEN_LEFT_PAREN */)) {
      return parseExpressionParentheses(parser);
    } else if (currentToken.data !== void 0 && !isOp) {
      return parseExpressionLiteral(parser);
    } else if (isOp && !isInvalidOp) {
      return parseExpressionPrefix(parser, prefix_bp_lookup(currentToken.type));
    } else {
      if (currentToken.type == "EOF" /* TOKEN_EOF */) {
        parser.pushError("Failed to parse primary expression - we expect some expression value but facing END");
      } else {
        parser.pushError("Failed to parse primary expression???");
      }
    }
    return void 0;
  }

  // phase/parser/parse/ast/expression/ternary.ts
  var AstExpressionTernary = class extends AstExpression {
    constructor(left, true_path, false_path) {
      super("ExpressionTernary");
      this.left = left;
      this.true_path = true_path;
      this.false_path = false_path;
      this.value_type = void 0;
    }
    getString() {
      return this.left.getString() + " ? " + this.true_path.getString() + " : " + this.false_path.getString();
    }
    stringify(wantsJson = true) {
      const obj = {
        type: "ExpressionTernary",
        left: this.left.stringify(false),
        true_path: this.true_path.stringify(false),
        false_path: this.false_path.stringify(false),
        value_type: this.value_type?.stringify(false)
      };
      return stringify(obj, wantsJson);
    }
  };

  // phase/parser/parse/expression/ternary.ts
  function parseExpressionTernary(parser, result) {
    parser.expect("TOKEN_QUESTION" /* TOKEN_QUESTION */);
    const true_path = parseExpression(parser);
    if (true_path === void 0) {
      return void 0;
    }
    parser.expect("COLON" /* TOKEN_COLON */);
    const false_path = parseExpression(parser);
    if (false_path === void 0) {
      return void 0;
    }
    const ast = new AstExpressionTernary(result, true_path, false_path);
    return ast;
  }

  // phase/parser/parse/ast/expression/postfix.ts
  var AstExpressionPostfix = class extends AstExpression {
    constructor(operator, operand) {
      super("ExpressionPostfix");
      this.operator = operator;
      this.right = operand;
      this.value_type = void 0;
    }
    getString() {
      return `${this.operator}${this.right.getString()}`;
    }
    stringify(wantsJson = true) {
      const obj = {
        type: "ExpressionPostfix",
        operator: this.operator,
        right: this.right.stringify(false)
      };
      return stringify(obj, wantsJson);
    }
  };

  // phase/parser/parse/expression/postfix.ts
  function parseExpresssionPostfix(parser, result) {
    const op = parser.currentToken;
    if (op.type !== "NOT" /* TOKEN_NOT */) {
      parser.pushError("Expected postfix operator but got '" + op.enduser_token + "'");
      return void 0;
    }
    const ast = new AstExpressionPostfix(op.type, result);
    return ast;
  }

  // phase/parser/parse/ast/function/function_parameter.ts
  var AstFunctionParameter = class extends AstNode {
    constructor(value) {
      super("FunctionParameter");
      this.value = value;
    }
  };

  // phase/parser/parse/ast/function/function_call.ts
  var AstExpressionFunctionCall = class extends AstExpression {
    constructor(left, parameters) {
      super("ExpressionFunctionCall");
      this.left = left;
      this.parameters = parameters;
      this.generated_value = void 0;
    }
    getString() {
      if (this.generated_value !== void 0) {
        return this.generated_value;
      }
      return this.left.getString();
    }
    stringify(wantsJson = true) {
      const obj = {
        type: "ExpressionFunctionCall",
        left: this.left.stringify(false),
        parameters: this.parameters.map((param) => param.stringify(false))
      };
      return stringify(obj, wantsJson);
    }
  };

  // phase/parser/parse/function/function_call.ts
  function parseExpressionFunctionCall(parser, functionName) {
    const parameters = [];
    parser.next();
    if (!parser.has("RIGHT_PAREN" /* TOKEN_RIGHT_PAREN */)) {
      do {
        const parameter_value = parseExpression(parser);
        if (parameter_value === void 0) {
          parser.pushError("Expected an expression as function argument.");
          break;
        }
        const parameter = new AstFunctionParameter(parameter_value);
        parameters.push(parameter);
      } while (parser.skip("COMMA" /* TOKEN_COMMA */));
    }
    parser.expect("RIGHT_PAREN" /* TOKEN_RIGHT_PAREN */);
    return new AstExpressionFunctionCall(functionName, parameters);
  }

  // phase/parser/parse/expression/expression.ts
  function parseExpression(parser, binding_power_to_my_right = 0) {
    let result = parseExpressionPrimary(parser);
    if (result === void 0) {
      parser.pushError("Expected expression but primary expression was not found.");
      return void 0;
    }
    while (binding_power_to_my_right < bp_lookup(parser.currentToken.type).left_power) {
      if (result === void 0) {
        parser.pushError("Expected expression but we got undefined in process of parsing expression.");
        return void 0;
      }
      if (parser.has("NOT" /* TOKEN_NOT */)) {
        result = parseExpresssionPostfix(parser, result);
      } else if (parser.has("TOKEN_QUESTION" /* TOKEN_QUESTION */)) {
        result = parseExpressionTernary(parser, result);
      } else if (parser.has("LEFT_PAREN" /* TOKEN_LEFT_PAREN */)) {
        result = parseExpressionFunctionCall(parser, result);
      } else {
        result = parseExpressionBinary(parser, result, bp_lookup(parser.currentToken.type).right_power);
      }
    }
    return result;
  }

  // phase/parser/parse/layout/attribute_value.ts
  function parserParseLayoutAttributeValue(parser, element_enduser_name, key) {
    return parseExpression(parser);
  }

  // phase/validator/validation/symbol-table.ts
  var SymbolTable = class {
    constructor() {
      this.table = /* @__PURE__ */ new Map();
    }
    addSymbol(name, type) {
      this.table.set(name, type);
    }
    addSystemSymbol(name, type) {
      this.table.set(name, type);
    }
    getSymbol(name) {
      return this.table.get(name);
    }
    hasSymbol(name) {
      return this.table.has(name);
    }
    removeSymbol(name) {
      return this.table.delete(name);
    }
    stringify(wantsJson = true) {
      const obj = {
        table: this.table.entries()
      };
      return stringify(obj, wantsJson);
    }
  };

  // runtime/element.ts
  var RuntimeElement = class {
    is_mother;
    generate_name = void 0;
    text;
    attributes;
    belongs_to;
    constructor(is_mother, generate_name) {
      this.is_mother = is_mother;
      this.text = /* @__PURE__ */ new Map();
      this.generate_name = generate_name;
      this.attributes = [];
      this.belongs_to = [];
    }
    findAttribute(languageId, name) {
      return this.attributes.find(
        (attribute) => attribute.getText(languageId)?.includes(name)
      );
    }
    hasAttribute(languageId, name) {
      return this.findAttribute(languageId, name) !== void 0;
    }
    getAttribute(languageId, name) {
      return this.findAttribute(languageId, name);
    }
    addBelongsTo(element) {
      this.belongs_to.push(element);
    }
    addText(languageId, value) {
      if (!this.text.has(languageId)) {
        this.text.set(languageId, []);
      }
      this.text.get(languageId).push(value);
    }
    getText(languageId) {
      return this.text.get(languageId);
    }
    addAttribute(attribute) {
      this.attributes.push(attribute);
    }
    addReservedValue(reservedValue) {
      this.attributes.push(reservedValue);
    }
  };

  // runtime/data/element/language.ts
  var languages = [
    { "name": "Abkhazian", "code": "ab" },
    { "name": "Afar", "code": "aa" },
    { "name": "Afrikaans", "code": "af" },
    { "name": "Akan", "code": "ak" },
    { "name": "Albanian", "code": "sq" },
    { "name": "Amharic", "code": "am" },
    { "name": "Arabic", "code": "ar" },
    { "name": "Aragonese", "code": "an" },
    { "name": "Armenian", "code": "hy" },
    { "name": "Assamese", "code": "as" },
    { "name": "Avaric", "code": "av" },
    { "name": "Avestan", "code": "ae" },
    { "name": "Aymara", "code": "ay" },
    { "name": "Azerbaijani", "code": "az" },
    { "name": "Bambara", "code": "bm" },
    { "name": "Bashkir", "code": "ba" },
    { "name": "Basque", "code": "eu" },
    { "name": "Belarusian", "code": "be" },
    { "name": "Bengali", "code": "bn" },
    { "name": "Bangla", "code": "bn" },
    { "name": "Bihari", "code": "bh" },
    { "name": "Bislama", "code": "bi" },
    { "name": "Bosnian", "code": "bs" },
    { "name": "Breton", "code": "br" },
    { "name": "Bulgarian", "code": "bg" },
    { "name": "Burmese", "code": "my" },
    { "name": "Catalan", "code": "ca" },
    { "name": "Chamorro", "code": "ch" },
    { "name": "Chechen", "code": "ce" },
    { "name": "Chichewa, Chewa, Nyanja", "code": "ny" },
    { "name": "Chinese", "code": "zh" },
    { "name": "Chinese Simplified", "code": "zh-Hans" },
    { "name": "Chinese Traditional", "code": "zh-Hant" },
    { "name": "Chuvash", "code": "cv" },
    { "name": "Cornish", "code": "kw" },
    { "name": "Corsican", "code": "co" },
    { "name": "Cree", "code": "cr" },
    { "name": "Croatian", "code": "hr" },
    { "name": "Czech", "code": "cs" },
    { "name": "Danish", "code": "da" },
    { "name": "Divehi", "code": "dv" },
    { "name": "Dhivehi", "code": "dv" },
    { "name": "Maldivian", "code": "dv" },
    { "name": "Dutch", "code": "nl" },
    { "name": "Dzongkha", "code": "dz" },
    { "name": "English", "code": "en" },
    { "name": "Esperanto", "code": "eo" },
    { "name": "Estonian", "code": "et" },
    { "name": "Ewe", "code": "ee" },
    { "name": "Faroese", "code": "fo" },
    { "name": "Fijian", "code": "fj" },
    { "name": "Finnish", "code": "fi" },
    { "name": "French", "code": "fr" },
    { "name": "Fula, Fulah, Pulaar, Pular", "code": "ff" },
    { "name": "Galician", "code": "gl" },
    { "name": "Gaelic Scottish", "code": "gd" },
    { "name": "Gaelic Manx", "code": "gv" },
    { "name": "Georgian", "code": "ka" },
    { "name": "German", "code": "de" },
    { "name": "Greek", "code": "el" },
    { "name": "Greenlandic", "code": "kl" },
    { "name": "Guarani", "code": "gn" },
    { "name": "Gujarati", "code": "gu" },
    { "name": "Haitian Creole", "code": "ht" },
    { "name": "Hausa", "code": "ha" },
    { "name": "Hebrew", "code": "he" },
    { "name": "Herero", "code": "hz" },
    { "name": "Hindi", "code": "hi" },
    { "name": "Hiri Motu", "code": "ho" },
    { "name": "Hungarian", "code": "hu" },
    { "name": "Icelandic", "code": "is" },
    { "name": "Ido", "code": "io" },
    { "name": "Igbo", "code": "ig" },
    { "name": "Indonesian", "code": "id, in" },
    { "name": "Interlingua", "code": "ia" },
    { "name": "Interlingue", "code": "ie" },
    { "name": "Inuktitut", "code": "iu" },
    { "name": "Inupiak", "code": "ik" },
    { "name": "Irish", "code": "ga" },
    { "name": "Italian", "code": "it" },
    { "name": "Japanese", "code": "ja" },
    { "name": "Javanese", "code": "jv" },
    { "name": "Kalaallisut", "code": "kl" },
    { "name": "Greenlandic", "code": "kl" },
    { "name": "Kannada", "code": "kn" },
    { "name": "Kanuri", "code": "kr" },
    { "name": "Kashmiri", "code": "ks" },
    { "name": "Kazakh", "code": "kk" },
    { "name": "Khmer", "code": "km" },
    { "name": "Kikuyu", "code": "ki" },
    { "name": "Kinyarwanda Rwanda", "code": "rw" },
    { "name": "Kirundi", "code": "rn" },
    { "name": "Kyrgyz", "code": "ky" },
    { "name": "Komi", "code": "kv" },
    { "name": "Kongo", "code": "kg" },
    { "name": "Korean", "code": "ko" },
    { "name": "Kurdish", "code": "ku" },
    { "name": "Kwanyama", "code": "kj" },
    { "name": "Lao", "code": "lo" },
    { "name": "Latin", "code": "la" },
    { "name": "Latvian Lettish", "code": "lv" },
    { "name": "Limburgish Limburger", "code": "li" },
    { "name": "Lingala", "code": "ln" },
    { "name": "Lithuanian", "code": "lt" },
    { "name": "Luga-Katanga", "code": "lu" },
    { "name": "Luganda, Ganda", "code": "lg" },
    { "name": "Luxembourgish", "code": "lb" },
    { "name": "Manx", "code": "gv" },
    { "name": "Macedonian", "code": "mk" },
    { "name": "Malagasy", "code": "mg" },
    { "name": "Malay", "code": "ms" },
    { "name": "Malayalam", "code": "ml" },
    { "name": "Maltese", "code": "mt" },
    { "name": "Maori", "code": "mi" },
    { "name": "Marathi", "code": "mr" },
    { "name": "Marshallese", "code": "mh" },
    { "name": "Moldavian", "code": "mo" },
    { "name": "Mongolian", "code": "mn" },
    { "name": "Nauru", "code": "na" },
    { "name": "Navajo", "code": "nv" },
    { "name": "Ndonga", "code": "ng" },
    { "name": "Northern Ndebele", "code": "nd" },
    { "name": "Nepali", "code": "ne" },
    { "name": "Norwegian", "code": "no" },
    { "name": "Norwegian bokm\xE5l", "code": "nb" },
    { "name": "Norwegian nynorsk", "code": "nn" },
    { "name": "Nuosu", "code": "ii" },
    { "name": "Occitan", "code": "oc" },
    { "name": "Ojibwe", "code": "oj" },
    { "name": "Old Church Slavonic, Old Bulgarian", "code": "cu" },
    { "name": "Oriya", "code": "or" },
    { "name": "Oromo Afaan Oromo", "code": "om" },
    { "name": "Ossetian", "code": "os" },
    { "name": "P\u0101li", "code": "pi" },
    { "name": "Pashto, Pushto", "code": "ps" },
    { "name": "Persian", "code": "fa" },
    { "name": "Farsi", "code": "fa" },
    { "name": "Polish", "code": "pl" },
    { "name": "Portuguese", "code": "pt" },
    { "name": "Punjabi", "code": "pa" },
    { "name": "Eastern", "code": "pa" },
    { "name": "Quechua", "code": "qu" },
    { "name": "Romansh", "code": "rm" },
    { "name": "Romanian", "code": "ro" },
    { "name": "Russian", "code": "ru" },
    { "name": "Sami", "code": "se" },
    { "name": "Samoan", "code": "sm" },
    { "name": "Sango", "code": "sg" },
    { "name": "Sanskrit", "code": "sa" },
    { "name": "Serbian", "code": "sr" },
    { "name": "Serbo-Croatian", "code": "sh" },
    { "name": "Sesotho", "code": "st" },
    { "name": "Setswana", "code": "tn" },
    { "name": "Shona", "code": "sn" },
    { "name": "Sichuan Yi", "code": "ii" },
    { "name": "Sindhi", "code": "sd" },
    { "name": "Sinhalese", "code": "si" },
    { "name": "Siswati", "code": "ss" },
    { "name": "Slovak", "code": "sk" },
    { "name": "Slovenian", "code": "sl" },
    { "name": "Somali", "code": "so" },
    { "name": "Southern Ndebele", "code": "nr" },
    { "name": "Spanish", "code": "es" },
    { "name": "Sundanese", "code": "su" },
    { "name": "Swahili", "code": "sw" },
    { "name": "Kiswahili", "code": "sw" },
    { "name": "Swati", "code": "ss" },
    { "name": "Swedish", "code": "sv" },
    { "name": "Tagalog", "code": "tl" },
    { "name": "Tahitian", "code": "ty" },
    { "name": "Tajik", "code": "tg" },
    { "name": "Tamil", "code": "ta" },
    { "name": "Tatar", "code": "tt" },
    { "name": "Telugu", "code": "te" },
    { "name": "Thai", "code": "th" },
    { "name": "Tibetan", "code": "bo" },
    { "name": "Tigrinya", "code": "ti" },
    { "name": "Tonga", "code": "to" },
    { "name": "Tsonga", "code": "ts" },
    { "name": "Turkish", "code": "tr" },
    { "name": "Turkmen", "code": "tk" },
    { "name": "Twi", "code": "tw" },
    { "name": "Uyghur", "code": "ug" },
    { "name": "Ukrainian", "code": "uk" },
    { "name": "Urdu", "code": "ur" },
    { "name": "Uzbek", "code": "uz" },
    { "name": "Venda", "code": "ve" },
    { "name": "Vietnamese", "code": "vi" },
    { "name": "Volap\xFCk", "code": "vo" },
    { "name": "Wallon", "code": "wa" },
    { "name": "Welsh", "code": "cy" },
    { "name": "Wolof", "code": "wo" },
    { "name": "Western Frisian", "code": "fy" },
    { "name": "Xhosa", "code": "xh" },
    { "name": "Yiddish", "code": "yi" },
    { "name": "Yiddish", "code": "ji" },
    { "name": "Yoruba", "code": "yo" },
    { "name": "Zhuang", "code": "za" },
    { "name": "Chuang", "code": "za" },
    { "name": "Zulu", "code": "zu" }
  ];

  // runtime/data/element/mediatypes.ts
  var mediatypes = [
    "external",
    "internal",
    "download"
  ];

  // runtime/element_attribute.ts
  var RuntimeElementAttribute = class {
    generate_name;
    kind;
    text;
    type;
    output_type;
    reservedValues;
    is_required;
    is_hide;
    constructor(type, generate_name) {
      this.kind = "Normal" /* Normal */;
      this.type = type;
      this.generate_name = generate_name;
      this.text = /* @__PURE__ */ new Map();
      this.output_type = "Normal" /* Normal */;
      this.reservedValues = [];
      this.is_required = false;
      this.is_hide = false;
    }
    setOutputType(outputType) {
      this.output_type = outputType;
      return this;
    }
    setStyle() {
      this.kind = "Style" /* Style */;
      return this;
    }
    setHide() {
      this.is_hide = true;
      return this;
    }
    setRequired() {
      this.is_required = true;
      return this;
    }
    addText(languageId, value) {
      if (!this.text.has(languageId)) {
        this.text.set(languageId, []);
      }
      this.text.get(languageId).push(value);
      return this;
    }
    getText(languageId) {
      return this.text.get(languageId);
    }
    addReservedValue(reservedValue) {
      this.reservedValues.push(reservedValue);
      return this;
    }
    addReservedValues(reservedValues) {
      for (const reservedValue of reservedValues) {
        this.addReservedValue(reservedValue);
      }
      return this;
    }
  };

  // runtime/element_attribute_value.ts
  var RuntimeElementAttributeValue = class {
    generate_name;
    text;
    constructor(generate_name) {
      this.generate_name = generate_name;
      this.text = /* @__PURE__ */ new Map();
    }
    addText(languageId, value) {
      if (!this.text.has(languageId)) {
        this.text.set(languageId, []);
      }
      this.text.get(languageId).push(value);
      return this;
    }
    addAllText(value) {
      for (const languageId of Object.values(LanguageID)) {
        this.addText(languageId, value);
      }
      return this;
    }
    getText(languageId) {
      return this.text.get(languageId);
    }
  };

  // runtime/element/a.ts
  var RuntimeElementA = class extends RuntimeElement {
    constructor() {
      super(true, "a");
      this.addText("English" /* LanguageEnglish */, "link");
      this.addText("Persian" /* LanguagePersian */, "\u067E\u06CC\u0648\u0646\u062F");
      this.addAttribute(
        new RuntimeElementAttribute(
          "StringNoEmpty" /* StringNoEmpty */,
          "download"
        ).addText("Persian" /* LanguagePersian */, "\u0628\u0627\u0631\u06AF\u06CC\u0631\u06CC").addText("English" /* LanguageEnglish */, "download")
      );
      this.addAttribute(
        new RuntimeElementAttribute("Url" /* Url */, "href").addText("Persian" /* LanguagePersian */, "\u0645\u0646\u0628\u0639").addText("English" /* LanguageEnglish */, "source")
      );
      this.addAttribute(
        new RuntimeElementAttribute(
          "String" /* String */,
          "hreflang"
        ).addText("Persian" /* LanguagePersian */, "language").addText("English" /* LanguageEnglish */, "\u0632\u0628\u0627\u0646").addReservedValues(
          languages.map(
            (language) => new RuntimeElementAttributeValue(language.code.toUpperCase()).addAllText(language.name).addAllText(language.code)
          )
        )
      );
      this.addAttribute(
        new RuntimeElementAttribute("CSSMedia" /* CSSMedia */, "media").addText("English" /* LanguageEnglish */, "media").addText("Persian" /* LanguagePersian */, "\u0631\u0633\u0627\u0646\u0647")
      );
      this.addAttribute(
        new RuntimeElementAttribute("Urls" /* Urls */, "ping").addText("English" /* LanguageEnglish */, "ping").addText("Persian" /* LanguagePersian */, "\u067E\u0698\u0648\u0627\u06A9")
      );
      this.addAttribute(
        new RuntimeElementAttribute("String" /* String */, "referrerpolicy").addText("English" /* LanguageEnglish */, "referrerpolicy").addText("Persian" /* LanguagePersian */, "\u0633\u06CC\u0627\u0633\u062A \u0627\u0631\u062C\u0627\u0639")
      );
      this.addAttribute(
        new RuntimeElementAttribute("String" /* String */, "rel").addText("English" /* LanguageEnglish */, "rel").addText("Persian" /* LanguagePersian */, "\u0631\u0627\u0628\u0637\u0647")
      );
      this.addAttribute(
        new RuntimeElementAttribute("String" /* String */, "target").addText("English" /* LanguageEnglish */, "target").addText("Persian" /* LanguagePersian */, "\u0647\u062F\u0641")
      );
      this.addAttribute(
        new RuntimeElementAttribute("String" /* String */, "type").addText("English" /* LanguageEnglish */, "type").addText("Persian" /* LanguagePersian */, "\u06AF\u0648\u0646\u0647").addReservedValues(
          mediatypes.map(
            (mediatype) => new RuntimeElementAttributeValue(mediatype).addAllText(mediatype)
          )
        )
      );
    }
  };

  // runtime/element/div.ts
  var RuntimeElementDiv = class extends RuntimeElement {
    constructor() {
      super(true, "div");
      this.addText("English" /* LanguageEnglish */, "box");
      this.addText("Persian" /* LanguagePersian */, "\u0642\u0633\u0645\u062A");
    }
  };

  // runtime/element/custom/layout.ts
  var RuntimeElementLayout = class extends RuntimeElement {
    constructor() {
      super(true, void 0);
      this.addText("English" /* LanguageEnglish */, "layout");
      this.addText("Persian" /* LanguagePersian */, "\u0644\u0627\u06CC\u0647");
      this.addAttribute(
        new RuntimeElementAttribute("AnyNoEmpty" /* AnyNoEmpty */, "title").addText("Persian" /* LanguagePersian */, "\u0639\u0646\u0648\u0627\u0646").addText("English" /* LanguageEnglish */, "title").setHide()
      );
      this.addAttribute(
        new RuntimeElementAttribute("AnyNoEmpty" /* AnyNoEmpty */, "author").addText("Persian" /* LanguagePersian */, "\u0646\u0648\u06CC\u0633\u0646\u062F\u0647").addText("English" /* LanguageEnglish */, "author").setHide()
      );
      this.addAttribute(
        new RuntimeElementAttribute("AnyNoEmpty" /* AnyNoEmpty */, "lang").addText("Persian" /* LanguagePersian */, "\u0632\u0628\u0627\u0646").addText("English" /* LanguageEnglish */, "language").setHide()
      );
      this.addAttribute(
        new RuntimeElementAttribute("StringNoEmpty" /* StringNoEmpty */, "dir").addText("Persian" /* LanguagePersian */, "\u062C\u0647\u062A").addText("English" /* LanguageEnglish */, "direction").setHide().addReservedValues([
          new RuntimeElementAttributeValue("ltr").addText("Persian" /* LanguagePersian */, "\u0686\u067E \u0628\u0647 \u0631\u0627\u0633\u062A").addText("English" /* LanguageEnglish */, "left to right"),
          new RuntimeElementAttributeValue("rtl").addText("Persian" /* LanguagePersian */, "\u0631\u0627\u0633\u062A \u0628\u0647 \u0686\u067E").addText("English" /* LanguageEnglish */, "right to left"),
          new RuntimeElementAttributeValue("rtl").addAllText("rtl"),
          new RuntimeElementAttributeValue("ltr").addAllText("ltr")
        ])
      );
    }
  };

  // runtime/element/custom/include.ts
  var RuntimeElementInclude = class extends RuntimeElement {
    constructor() {
      super(true, void 0);
      this.addText("English" /* LanguageEnglish */, "include");
      this.addText("Persian" /* LanguagePersian */, "\u0634\u0627\u0645\u0644");
      this.addAttribute(
        new RuntimeElementAttribute("Uri" /* Uri */, "source").addText("Persian" /* LanguagePersian */, "\u0645\u0646\u0628\u0639").addText("English" /* LanguageEnglish */, "source").setRequired()
      );
    }
  };

  // runtime/element_attribute_style.ts
  var RuntimeElementAttributeStyle = class extends RuntimeElementAttribute {
    constructor(type, generate_name) {
      super(type, generate_name);
      this.kind = "Style" /* Style */;
    }
  };

  // runtime/style/attribute/accent-color.ts
  var RuntimeStyleAccentColor = class extends RuntimeElementAttributeStyle {
    constructor() {
      super("Color" /* Color */, "accent-color");
      this.addText("Persian" /* LanguagePersian */, "\u0631\u0646\u06AF \u062A\u0627\u06A9\u06CC\u062F\u06CC");
      this.addText("English" /* LanguageEnglish */, "accent color");
      this.addReservedValue(
        new RuntimeElementAttributeValue("auto").addText("English" /* LanguageEnglish */, "auto").addText("Persian" /* LanguagePersian */, "\u062E\u0648\u062F\u06A9\u0627\u0631")
      );
    }
  };

  // runtime/style/attribute/all.ts
  var RuntimeStyleAll = class extends RuntimeElementAttributeStyle {
    constructor() {
      super("StringNoEmpty" /* StringNoEmpty */, "all");
      this.addText("Persian" /* LanguagePersian */, "\u0647\u0645\u0647");
      this.addText("English" /* LanguageEnglish */, "all");
      this.addReservedValue(
        new RuntimeElementAttributeValue("initial").addText("English" /* LanguageEnglish */, "initial").addText("Persian" /* LanguagePersian */, "\u0627\u0648\u0644\u06CC\u0647")
      );
      this.addReservedValue(
        new RuntimeElementAttributeValue("inherit").addText("English" /* LanguageEnglish */, "inherit").addText("Persian" /* LanguagePersian */, "\u0627\u0631\u062B \u0628\u0631\u06CC")
      );
      this.addReservedValue(
        new RuntimeElementAttributeValue("unset").addText("English" /* LanguageEnglish */, "unset").addText("Persian" /* LanguagePersian */, "\u0646\u0627\u0645\u0634\u062E\u0635")
      );
      this.addReservedValue(
        new RuntimeElementAttributeValue("revert").addText("English" /* LanguageEnglish */, "revert").addText("Persian" /* LanguagePersian */, "\u0628\u0631\u06AF\u0631\u062F\u0627\u0646")
      );
      this.addReservedValue(
        new RuntimeElementAttributeValue("revert-layer").addText("English" /* LanguageEnglish */, "revert-layer").addText("Persian" /* LanguagePersian */, "\u0628\u0631\u06AF\u0631\u062F\u0627\u0646-\u0644\u0627\u06CC\u0647")
      );
    }
  };

  // runtime/data/style/values/single-animation-composition.ts
  var single_animation_composition = [
    new RuntimeElementAttributeValue("replace").addText("English" /* LanguageEnglish */, "replace").addText("Persian" /* LanguagePersian */, "\u062C\u0627\u06CC\u06AF\u0632\u06CC\u0646\u06CC"),
    new RuntimeElementAttributeValue("add").addText("English" /* LanguageEnglish */, "add").addText("Persian" /* LanguagePersian */, "\u0627\u0636\u0627\u0641\u0647 \u06A9\u0631\u062F\u0646"),
    new RuntimeElementAttributeValue("accumulate").addText("English" /* LanguageEnglish */, "accumulate").addText("Persian" /* LanguagePersian */, "\u062A\u062C\u0645\u0639\u06CC")
  ];

  // runtime/style/attribute/animation-composition.ts
  var RuntimeStyleAnimationComposition = class extends RuntimeElementAttributeStyle {
    constructor() {
      super("Strings" /* Strings */, "animation-composition");
      this.addText("Persian" /* LanguagePersian */, "\u062A\u0631\u06A9\u06CC\u0628 \u0627\u0646\u06CC\u0645\u06CC\u0634\u0646");
      this.addText("English" /* LanguageEnglish */, "animation composition");
      this.addReservedValues(single_animation_composition);
    }
  };

  // runtime/style/attribute/animation-delay.ts
  var RuntimeStyleAnimationDelay = class extends RuntimeElementAttributeStyle {
    constructor() {
      super("Times" /* Times */, "animation-delay");
      this.addText("Persian" /* LanguagePersian */, "\u062A\u0627\u062E\u06CC\u0631 \u0627\u0646\u06CC\u0645\u06CC\u0634\u0646");
      this.addText("English" /* LanguageEnglish */, "animation delay");
    }
  };

  // runtime/data/style/values/single-animation-direction.ts
  var single_animation_direction = [
    new RuntimeElementAttributeValue("normal").addText("English" /* LanguageEnglish */, "normal").addText("Persian" /* LanguagePersian */, "\u0645\u0639\u0645\u0648\u0644\u06CC"),
    new RuntimeElementAttributeValue("reverse").addText("English" /* LanguageEnglish */, "reverse").addText("Persian" /* LanguagePersian */, "\u0645\u0639\u06A9\u0648\u0633"),
    new RuntimeElementAttributeValue("alternate").addText("English" /* LanguageEnglish */, "alternate").addText("Persian" /* LanguagePersian */, "\u062C\u0627\u06CC\u06AF\u0632\u06CC\u0646\u06CC"),
    new RuntimeElementAttributeValue("alternate-reverse").addText("English" /* LanguageEnglish */, "alternate reverse").addText("Persian" /* LanguagePersian */, "\u062C\u0627\u06CC\u06AF\u0632\u06CC\u0646\u06CC \u0645\u0639\u06A9\u0648\u0633")
  ];

  // runtime/style/attribute/animation-direction.ts
  var RuntimeStyleAnimationDirection = class extends RuntimeElementAttributeStyle {
    constructor() {
      super("Strings" /* Strings */, "animation-direction");
      this.addText("Persian" /* LanguagePersian */, "\u062A\u0627\u062E\u06CC\u0631 \u0627\u0646\u06CC\u0645\u06CC\u0634\u0646");
      this.addText("English" /* LanguageEnglish */, "animation direction");
      this.addReservedValues(single_animation_direction);
    }
  };

  // runtime/style/attribute/animation-duration.ts
  var RuntimeStyleAnimationDuration = class extends RuntimeElementAttributeStyle {
    constructor() {
      super("Times" /* Times */, "animation-duration");
      this.addText("Persian" /* LanguagePersian */, "\u0645\u062F\u062A \u0632\u0645\u0627\u0646 \u0627\u0646\u06CC\u0645\u06CC\u0634\u0646");
      this.addText("English" /* LanguageEnglish */, "animation duration");
    }
  };

  // runtime/data/style/values/single-animation-fill-mode.ts
  var single_animation_fill_mode = [
    new RuntimeElementAttributeValue("none").addText("English" /* LanguageEnglish */, "none").addText("Persian" /* LanguagePersian */, "\u0647\u06CC\u0686"),
    new RuntimeElementAttributeValue("forwards").addText("English" /* LanguageEnglish */, "forwards").addText("Persian" /* LanguagePersian */, "\u0628\u0647 \u062C\u0644\u0648"),
    new RuntimeElementAttributeValue("backwards").addText("English" /* LanguageEnglish */, "backwards").addText("Persian" /* LanguagePersian */, "\u0628\u0647 \u0639\u0642\u0628"),
    new RuntimeElementAttributeValue("both").addText("English" /* LanguageEnglish */, "both").addText("Persian" /* LanguagePersian */, "\u0647\u0631\u062F\u0648")
  ];

  // runtime/style/attribute/animation-fill-mode.ts
  var RuntimeStyleAnimationFillMode = class extends RuntimeElementAttributeStyle {
    constructor() {
      super("Times" /* Times */, "animation-fill-mode");
      this.addText("Persian" /* LanguagePersian */, "\u0645\u062F\u062A \u0632\u0645\u0627\u0646 \u0627\u0646\u06CC\u0645\u06CC\u0634\u0646");
      this.addText("English" /* LanguageEnglish */, "animation fill mode");
      this.addReservedValues(single_animation_fill_mode);
    }
  };

  // runtime/style/attribute/animation-iteration-count.ts
  var RuntimeStyleAnimationIterationCount = class extends RuntimeElementAttributeStyle {
    constructor() {
      super("PositiveInt" /* PositiveInt */, "animation-iteration-count");
      this.addText("Persian" /* LanguagePersian */, "\u062A\u0639\u062F\u0627\u062F \u0645\u0648\u0644\u062F \u0627\u0646\u06CC\u0645\u06CC\u0634\u0646");
      this.addText("English" /* LanguageEnglish */, "animation iteration count");
      this.addReservedValue(
        new RuntimeElementAttributeValue("infinite").addText("English" /* LanguageEnglish */, "infinite").addText("Persian" /* LanguagePersian */, "\u0628\u06CC \u0646\u0647\u0627\u06CC\u062A")
      );
    }
  };

  // runtime/style/attribute/animation-name.ts
  var RuntimeStyleAnimationName = class extends RuntimeElementAttributeStyle {
    constructor() {
      super("Strings" /* Strings */, "animation-name");
      this.addText("Persian" /* LanguagePersian */, "\u0646\u0627\u0645 \u0627\u0646\u06CC\u0645\u06CC\u0634\u0646");
      this.addText("English" /* LanguageEnglish */, "animation name");
      this.addReservedValue(
        new RuntimeElementAttributeValue("none").addText("English" /* LanguageEnglish */, "none").addText("Persian" /* LanguagePersian */, "\u0647\u06CC\u0686")
      );
    }
  };

  // runtime/style/attribute/animation-play-state.ts
  var RuntimeStyleAnimationPlayState = class extends RuntimeElementAttributeStyle {
    constructor() {
      super("Strings" /* Strings */, "animation-play-state");
      this.addText("Persian" /* LanguagePersian */, "\u0648\u0636\u0639\u06CC\u062A \u067E\u062E\u0634 \u0627\u0646\u06CC\u0645\u06CC\u0634\u0646");
      this.addText("English" /* LanguageEnglish */, "animation play state");
      this.addReservedValue(
        new RuntimeElementAttributeValue("running").addText("English" /* LanguageEnglish */, "running").addText("Persian" /* LanguagePersian */, "\u0627\u062C\u0631\u0627")
      );
      this.addReservedValue(
        new RuntimeElementAttributeValue("paused").addText("English" /* LanguageEnglish */, "paused").addText("Persian" /* LanguagePersian */, "\u0645\u062A\u0648\u0642\u0641 \u0634\u062F\u0647")
      );
    }
  };

  // runtime/style/attribute/animation-timing-function.ts
  var RuntimeStyleAnimationTimingFunction = class extends RuntimeElementAttributeStyle {
    constructor() {
      super("AnyNoEmpty" /* AnyNoEmpty */, "animation-timing-function");
      this.addText("Persian" /* LanguagePersian */, "\u062A\u0627\u0628\u0639 \u0632\u0645\u0627\u0646\u06CC \u0627\u0646\u06CC\u0645\u06CC\u0634\u0646");
      this.addText("English" /* LanguageEnglish */, "animation timing function");
    }
  };

  // runtime/data/style/values/compat-auto.ts
  var compat_auto = [
    new RuntimeElementAttributeValue("searchfield").addText("English" /* LanguageEnglish */, "searchfield").addText("Persian" /* LanguagePersian */, "\u062C\u0633\u062A\u062C\u0648"),
    new RuntimeElementAttributeValue("textarea").addText("English" /* LanguageEnglish */, "textarea").addText("Persian" /* LanguagePersian */, "\u0645\u062A\u0646"),
    new RuntimeElementAttributeValue("checkbox").addText("English" /* LanguageEnglish */, "checkbox").addText("Persian" /* LanguagePersian */, "\u0686\u06A9\u200C\u062C\u0639\u0628\u0647"),
    new RuntimeElementAttributeValue("radio").addText("English" /* LanguageEnglish */, "radio").addText("Persian" /* LanguagePersian */, "\u0631\u0627\u062F\u06CC\u0648"),
    new RuntimeElementAttributeValue("menulist").addText("English" /* LanguageEnglish */, "menulist").addText("Persian" /* LanguagePersian */, "\u0644\u06CC\u0633\u062A"),
    new RuntimeElementAttributeValue("listbox").addText("English" /* LanguageEnglish */, "listbox").addText("Persian" /* LanguagePersian */, "\u062C\u0639\u0628\u0647\u200C\u0644\u06CC\u0633\u062A"),
    new RuntimeElementAttributeValue("meter").addText("English" /* LanguageEnglish */, "meter").addText("Persian" /* LanguagePersian */, "\u0645\u062A\u0631"),
    new RuntimeElementAttributeValue("progress-bar").addText("English" /* LanguageEnglish */, "progress-bar").addText("Persian" /* LanguagePersian */, "\u0646\u0648\u0627\u0631\u067E\u06CC\u0634\u0631\u0641\u062A"),
    new RuntimeElementAttributeValue("button").addText("English" /* LanguageEnglish */, "button").addText("Persian" /* LanguagePersian */, "\u062F\u06A9\u0645\u0647")
  ];

  // runtime/data/style/values/compat-special.ts
  var compat_special = [
    new RuntimeElementAttributeValue("textfield").addText("English" /* LanguageEnglish */, "textfield").addText("Persian" /* LanguagePersian */, "\u0645\u062A\u0646"),
    new RuntimeElementAttributeValue("menulist-button").addText("English" /* LanguageEnglish */, "menulist-button").addText("Persian" /* LanguagePersian */, "\u0644\u06CC\u0633\u062A")
  ];

  // runtime/style/attribute/appearance.ts
  var RuntimeStyleAppearance = class extends RuntimeElementAttributeStyle {
    constructor() {
      super("AnyNoEmpty" /* AnyNoEmpty */, "appearance");
      this.addText("Persian" /* LanguagePersian */, "\u0638\u0627\u0647\u0631");
      this.addText("English" /* LanguageEnglish */, "appearance");
      this.addReservedValue(
        new RuntimeElementAttributeValue("none").addText("English" /* LanguageEnglish */, "none").addText("Persian" /* LanguagePersian */, "\u0647\u06CC\u0686")
      );
      this.addReservedValue(
        new RuntimeElementAttributeValue("auto").addText("English" /* LanguageEnglish */, "auto").addText("Persian" /* LanguagePersian */, "\u062E\u0648\u062F\u06A9\u0627\u0631")
      );
      this.addReservedValue(
        new RuntimeElementAttributeValue("base").addText("English" /* LanguageEnglish */, "base").addText("Persian" /* LanguagePersian */, "\u067E\u0627\u06CC\u0647")
      );
      this.addReservedValues(compat_auto);
      this.addReservedValues(compat_special);
    }
  };

  // runtime/style/attribute/aspect-ratio.ts
  var RuntimeStyleAspectRation = class extends RuntimeElementAttributeStyle {
    constructor() {
      super("NumberOr2Numbers" /* NumberOr2Numbers */, "aspect-ratio");
      this.addText("Persian" /* LanguagePersian */, "\u0646\u0633\u0628\u062A \u0627\u0628\u0639\u0627\u062F");
      this.addText("English" /* LanguageEnglish */, "aspect ratio");
      this.addReservedValue(
        new RuntimeElementAttributeValue("auto").addText("English" /* LanguageEnglish */, "auto").addText("Persian" /* LanguagePersian */, "\u062E\u0648\u062F\u06A9\u0627\u0631")
      );
    }
  };

  // runtime/style/attribute/backdrop-filter.ts
  var RuntimeStyleBackdropFilter = class extends RuntimeElementAttributeStyle {
    constructor() {
      super("AnyNoEmpty" /* AnyNoEmpty */, "backdrop-filter");
      this.addText("Persian" /* LanguagePersian */, "\u0641\u06CC\u0644\u062A\u0631 \u067E\u0633 \u0632\u0645\u06CC\u0646\u0647");
      this.addText("English" /* LanguageEnglish */, "backdrop filter");
      this.addReservedValue(
        new RuntimeElementAttributeValue("none").addText("English" /* LanguageEnglish */, "none").addText("Persian" /* LanguagePersian */, "\u0647\u06CC\u0686")
      );
    }
  };

  // runtime/style/attribute/backface-visibility.ts
  var RuntimeStyleBackfaceVisibility = class extends RuntimeElementAttributeStyle {
    constructor() {
      super("AnyNoEmpty" /* AnyNoEmpty */, "backface-visibility");
      this.addText("Persian" /* LanguagePersian */, "\u0642\u0627\u0628\u0644\u06CC\u062A \u062F\u06CC\u062F \u067E\u0634\u062A\u06CC");
      this.addText("English" /* LanguageEnglish */, "backface visibility");
      this.addReservedValue(
        new RuntimeElementAttributeValue("visible").addText("English" /* LanguageEnglish */, "visible").addText("Persian" /* LanguagePersian */, "\u0642\u0627\u0628\u0644 \u062F\u06CC\u062F")
      );
      this.addReservedValue(
        new RuntimeElementAttributeValue("hidden").addText("English" /* LanguageEnglish */, "hidden").addText("Persian" /* LanguagePersian */, "\u0645\u062E\u0641\u06CC")
      );
    }
  };

  // runtime/data/style/values/color.ts
  var color = [
    new RuntimeElementAttributeValue("red").addAllText("red").addText("Persian" /* LanguagePersian */, "\u0642\u0631\u0645\u0632"),
    new RuntimeElementAttributeValue("blue").addAllText("blue").addText("Persian" /* LanguagePersian */, "\u0622\u0628\u06CC").addText("Persian" /* LanguagePersian */, "\u0627\u0628\u06CC"),
    new RuntimeElementAttributeValue("green").addAllText("green").addText("Persian" /* LanguagePersian */, "\u0633\u0628\u0632"),
    new RuntimeElementAttributeValue("yellow").addAllText("yellow").addText("Persian" /* LanguagePersian */, "\u0632\u0631\u062F"),
    new RuntimeElementAttributeValue("black").addAllText("black").addText("Persian" /* LanguagePersian */, "\u0645\u0634\u06A9\u06CC").addText("Persian" /* LanguagePersian */, "\u0633\u06CC\u0627\u0647"),
    new RuntimeElementAttributeValue("white").addAllText("white").addText("Persian" /* LanguagePersian */, "\u0633\u0641\u06CC\u062F"),
    new RuntimeElementAttributeValue("orange").addAllText("orange").addText("Persian" /* LanguagePersian */, "\u0646\u0627\u0631\u0646\u062C\u06CC"),
    new RuntimeElementAttributeValue("purple").addAllText("purple").addText("Persian" /* LanguagePersian */, "\u0628\u0646\u0641\u0634"),
    new RuntimeElementAttributeValue("pink").addAllText("pink").addText("Persian" /* LanguagePersian */, "\u0635\u0648\u0631\u062A\u06CC"),
    new RuntimeElementAttributeValue("brown").addAllText("brown").addText("Persian" /* LanguagePersian */, "\u0642\u0647\u0648\u0647\u200C\u0627\u06CC"),
    new RuntimeElementAttributeValue("gray").addAllText("gray").addText("Persian" /* LanguagePersian */, "\u062E\u0627\u06A9\u0633\u062A\u0631\u06CC"),
    new RuntimeElementAttributeValue("cyan").addAllText("cyan").addText("Persian" /* LanguagePersian */, "\u0641\u06CC\u0631\u0648\u0632\u0647\u200C\u0627\u06CC"),
    new RuntimeElementAttributeValue("magenta").addAllText("magenta").addText("Persian" /* LanguagePersian */, "\u0627\u0631\u063A\u0648\u0627\u0646\u06CC"),
    new RuntimeElementAttributeValue("lime").addAllText("lime").addText("Persian" /* LanguagePersian */, "\u0644\u06CC\u0645\u0648\u06CC\u06CC"),
    new RuntimeElementAttributeValue("olive").addAllText("olive").addText("Persian" /* LanguagePersian */, "\u0632\u06CC\u062A\u0648\u0646\u06CC"),
    new RuntimeElementAttributeValue("teal").addAllText("teal").addText("Persian" /* LanguagePersian */, "\u0633\u0628\u0632 \u0622\u0628\u06CC"),
    new RuntimeElementAttributeValue("navy").addAllText("navy").addText("Persian" /* LanguagePersian */, "\u0633\u0631\u0645\u0647\u200C\u0627\u06CC"),
    new RuntimeElementAttributeValue("gold").addAllText("gold").addText("Persian" /* LanguagePersian */, "\u0637\u0644\u0627\u06CC\u06CC"),
    new RuntimeElementAttributeValue("silver").addAllText("silver").addText("Persian" /* LanguagePersian */, "\u0646\u0642\u0631\u0647\u200C\u0627\u06CC"),
    new RuntimeElementAttributeValue("beige").addAllText("beige").addText("Persian" /* LanguagePersian */, "\u0628\u0698"),
    new RuntimeElementAttributeValue("maroon").addAllText("maroon").addText("Persian" /* LanguagePersian */, "\u062E\u0631\u0645\u0627\u06CC\u06CC"),
    new RuntimeElementAttributeValue("ivory").addAllText("ivory").addText("Persian" /* LanguagePersian */, "\u0639\u0627\u062C\u06CC"),
    new RuntimeElementAttributeValue("turquoise").addAllText("turquoise").addText("Persian" /* LanguagePersian */, "\u0641\u06CC\u0631\u0648\u0632\u0647\u200C\u0627\u06CC"),
    new RuntimeElementAttributeValue("coral").addAllText("coral").addText("Persian" /* LanguagePersian */, "\u0645\u0631\u062C\u0627\u0646\u06CC"),
    new RuntimeElementAttributeValue("khaki").addAllText("khaki").addText("Persian" /* LanguagePersian */, "\u062E\u0627\u06A9\u06CC"),
    new RuntimeElementAttributeValue("indigo").addAllText("indigo").addText("Persian" /* LanguagePersian */, "\u0646\u06CC\u0644\u06CC"),
    new RuntimeElementAttributeValue("violet").addAllText("violet").addText("Persian" /* LanguagePersian */, "\u0628\u0646\u0641\u0634 \u0631\u0648\u0634\u0646"),
    new RuntimeElementAttributeValue("crimson").addAllText("crimson").addText("Persian" /* LanguagePersian */, "\u0632\u0631\u0634\u06A9\u06CC"),
    new RuntimeElementAttributeValue("peach").addAllText("peach").addText("Persian" /* LanguagePersian */, "\u0647\u0644\u0648\u0626\u06CC"),
    new RuntimeElementAttributeValue("mint").addAllText("mint").addText("Persian" /* LanguagePersian */, "\u0646\u0639\u0646\u0627\u06CC\u06CC"),
    new RuntimeElementAttributeValue("plum").addAllText("plum").addText("Persian" /* LanguagePersian */, "\u0622\u0644\u0648\u06CC\u06CC"),
    new RuntimeElementAttributeValue("azure").addAllText("azure").addText("Persian" /* LanguagePersian */, "\u0622\u0628\u06CC \u0631\u0648\u0634\u0646"),
    new RuntimeElementAttributeValue("charcoal").addAllText("charcoal").addText("Persian" /* LanguagePersian */, "\u0630\u063A\u0627\u0644\u06CC"),
    new RuntimeElementAttributeValue("rose").addAllText("rose").addText("Persian" /* LanguagePersian */, "\u0631\u0632"),
    new RuntimeElementAttributeValue("amber").addAllText("amber").addText("Persian" /* LanguagePersian */, "\u06A9\u0647\u0631\u0628\u0627\u06CC\u06CC"),
    new RuntimeElementAttributeValue("lavender").addAllText("lavender").addText("Persian" /* LanguagePersian */, "\u0627\u0633\u0637\u0648\u062E\u0648\u062F\u0648\u0633\u06CC"),
    new RuntimeElementAttributeValue("bronze").addAllText("bronze").addText("Persian" /* LanguagePersian */, "\u0628\u0631\u0646\u0632\u06CC")
  ];

  // runtime/style/attribute/background-color.ts
  var RuntimeStyleBackgroundColor = class extends RuntimeElementAttributeStyle {
    constructor() {
      super("Color" /* Color */, "background-color");
      this.addText("Persian" /* LanguagePersian */, "\u0631\u0646\u06AF \u067E\u0633 \u0632\u0645\u06CC\u0646\u0647");
      this.addText("English" /* LanguageEnglish */, "background color");
      this.addReservedValues(color);
    }
  };

  // runtime/style/attribute/block-size.ts
  var RuntimeStyleBlockSize = class extends RuntimeElementAttributeStyle {
    constructor() {
      super("AnyNoEmpty" /* Width */, "block-size");
      this.addText("Persian" /* LanguagePersian */, "\u0642\u0627\u0628\u0644\u06CC\u062A \u062F\u06CC\u062F \u067E\u0634\u062A\u06CC");
      this.addText("English" /* LanguageEnglish */, "block size");
    }
  };

  // runtime/style/attribute/bottom.ts
  var RuntimeStyleBottom = class extends RuntimeElementAttributeStyle {
    constructor() {
      super("AnyNoEmpty" /* AnyNoEmpty */, "bottom");
      this.addText("Persian" /* LanguagePersian */, "\u067E\u0627\u06CC\u06CC\u0646");
      this.addText("English" /* LanguageEnglish */, "bottom");
    }
  };

  // runtime/style/attribute/caption-side.ts
  var RuntimeStyleCaptionSide = class extends RuntimeElementAttributeStyle {
    constructor() {
      super("AnyNoEmpty" /* Width */, "caption-side");
      this.addText("Persian" /* LanguagePersian */, "\u0642\u0627\u0628\u0644\u06CC\u062A \u062F\u06CC\u062F \u067E\u0634\u062A\u06CC");
      this.addText("English" /* LanguageEnglish */, "caption side");
      this.addReservedValue(
        new RuntimeElementAttributeValue("top").addText("Persian" /* LanguagePersian */, "\u0628\u0627\u0644\u0627").addText("English" /* LanguageEnglish */, "top")
      );
      this.addReservedValue(
        new RuntimeElementAttributeValue("bottom").addText("Persian" /* LanguagePersian */, "\u067E\u0627\u06CC\u06CC\u0646").addText("English" /* LanguageEnglish */, "bottom")
      );
    }
  };

  // runtime/style/attribute/caret-color.ts
  var RuntimeStyleCaretColor = class extends RuntimeElementAttributeStyle {
    constructor() {
      super("Color" /* Color */, "caret-color");
      this.addText("Persian" /* LanguagePersian */, "\u0642\u0627\u0628\u0644\u06CC\u062A \u062F\u06CC\u062F \u067E\u0634\u062A\u06CC");
      this.addText("English" /* LanguageEnglish */, "caret color");
      this.addReservedValue(
        new RuntimeElementAttributeValue("auto").addText("Persian" /* LanguagePersian */, "\u062E\u0648\u062F\u06A9\u0627\u0631").addText("English" /* LanguageEnglish */, "auto")
      );
    }
  };

  // runtime/style/attribute/clear.ts
  var RuntimeStyleClear = class extends RuntimeElementAttributeStyle {
    constructor() {
      super("Color" /* Color */, "clear");
      this.addText("Persian" /* LanguagePersian */, "\u067E\u0627\u06A9 \u06A9\u0631\u062F\u0646");
      this.addText("English" /* LanguageEnglish */, "clear");
      this.addReservedValue(
        new RuntimeElementAttributeValue("inline-start").addText("Persian" /* LanguagePersian */, "\u0634\u0631\u0648\u0639 \u062F\u0631\u0648\u0646 \u062E\u0637").addText("English" /* LanguageEnglish */, "inline start")
      );
      this.addReservedValue(
        new RuntimeElementAttributeValue("inline-end").addText("Persian" /* LanguagePersian */, "\u067E\u0627\u06CC\u0627\u0646 \u062F\u0631\u0648\u0646 \u062E\u0637").addText("English" /* LanguageEnglish */, "inline end")
      );
      this.addReservedValue(
        new RuntimeElementAttributeValue("block-start").addText("Persian" /* LanguagePersian */, "\u0634\u0631\u0648\u0639 \u0628\u0644\u0648\u06A9").addText("English" /* LanguageEnglish */, "block start")
      );
      this.addReservedValue(
        new RuntimeElementAttributeValue("block-end").addText("Persian" /* LanguagePersian */, "\u067E\u0627\u06CC\u0627\u0646 \u0628\u0644\u0648\u06A9").addText("English" /* LanguageEnglish */, "block end")
      );
      this.addReservedValue(
        new RuntimeElementAttributeValue("left").addText("Persian" /* LanguagePersian */, "\u0686\u067E").addText("English" /* LanguageEnglish */, "left")
      );
      this.addReservedValue(
        new RuntimeElementAttributeValue("right").addText("Persian" /* LanguagePersian */, "\u0631\u0627\u0633\u062A").addText("English" /* LanguageEnglish */, "right")
      );
      this.addReservedValue(
        new RuntimeElementAttributeValue("top").addText("Persian" /* LanguagePersian */, "\u0628\u0627\u0644\u0627").addText("English" /* LanguageEnglish */, "top")
      );
      this.addReservedValue(
        new RuntimeElementAttributeValue("bottom").addText("Persian" /* LanguagePersian */, "\u067E\u0627\u06CC\u06CC\u0646").addText("English" /* LanguageEnglish */, "bottom")
      );
      this.addReservedValue(
        new RuntimeElementAttributeValue("both-inline").addText("Persian" /* LanguagePersian */, "\u0647\u0631 \u062F\u0648 \u062F\u0631\u0648\u0646 \u062E\u0637").addText("English" /* LanguageEnglish */, "both inline")
      );
      this.addReservedValue(
        new RuntimeElementAttributeValue("both-block").addText("Persian" /* LanguagePersian */, "\u0647\u0631 \u062F\u0648 \u0628\u0644\u0648\u06A9").addText("English" /* LanguageEnglish */, "both block")
      );
      this.addReservedValue(
        new RuntimeElementAttributeValue("both").addText("Persian" /* LanguagePersian */, "\u0647\u0631 \u062F\u0648").addText("English" /* LanguageEnglish */, "both")
      );
      this.addReservedValue(
        new RuntimeElementAttributeValue("none").addText("Persian" /* LanguagePersian */, "\u0647\u06CC\u0686").addText("English" /* LanguageEnglish */, "none")
      );
    }
  };

  // runtime/style/attribute/color.ts
  var RuntimeStyleColor = class extends RuntimeElementAttributeStyle {
    constructor() {
      super("Color" /* Color */, "color");
      this.addText("Persian" /* LanguagePersian */, "\u0631\u0646\u06AF");
      this.addText("English" /* LanguageEnglish */, "color");
      this.addReservedValues(color);
    }
  };

  // runtime/style/attribute/font-size.ts
  var RuntimeStyleFontSize = class extends RuntimeElementAttributeStyle {
    constructor() {
      super("Size" /* Size */, "font-size");
      this.addText("Persian" /* LanguagePersian */, "\u0627\u0646\u062F\u0627\u0632\u0647 \u0642\u0644\u0645");
      this.addText("English" /* LanguageEnglish */, "font size");
    }
  };

  // runtime/style/attribute/font-family.ts
  var RuntimeStyleFontFamily = class extends RuntimeElementAttributeStyle {
    constructor() {
      super("AnyNoEmpty" /* AnyNoEmpty */, "font-family");
      this.addText("Persian" /* LanguagePersian */, "\u0646\u0627\u0645 \u0642\u0644\u0645");
      this.addText("English" /* LanguageEnglish */, "font name");
    }
  };

  // runtime/style/attribute/text-align.ts
  var RuntimeStyleTextAlign = class extends RuntimeElementAttributeStyle {
    constructor() {
      super("StringNoEmpty" /* StringNoEmpty */, "text-align");
      this.addText("Persian" /* LanguagePersian */, "\u062C\u0647\u062A \u0645\u062A\u0646");
      this.addText("English" /* LanguageEnglish */, "text align");
      this.addReservedValue(
        new RuntimeElementAttributeValue("left").addText("English" /* LanguageEnglish */, "left").addText("Persian" /* LanguagePersian */, "\u0686\u067E")
      );
      this.addReservedValue(
        new RuntimeElementAttributeValue("right").addText("English" /* LanguageEnglish */, "right").addText("Persian" /* LanguagePersian */, "\u0631\u0627\u0633\u062A")
      );
      this.addReservedValue(
        new RuntimeElementAttributeValue("center").addText("English" /* LanguageEnglish */, "center").addText("Persian" /* LanguagePersian */, "\u0648\u0633\u0637")
      );
      this.addReservedValue(
        new RuntimeElementAttributeValue("justify").addText("English" /* LanguageEnglish */, "justify").addText("Persian" /* LanguagePersian */, "\u062A\u0631\u0627\u0632")
      );
      this.addReservedValue(
        new RuntimeElementAttributeValue("start").addText("English" /* LanguageEnglish */, "start").addText("Persian" /* LanguagePersian */, "\u0634\u0631\u0648\u0639")
      );
      this.addReservedValue(
        new RuntimeElementAttributeValue("end").addText("English" /* LanguageEnglish */, "end").addText("Persian" /* LanguagePersian */, "\u067E\u0627\u06CC\u0627\u0646")
      );
      this.addReservedValue(
        new RuntimeElementAttributeValue("match-parent").addText("English" /* LanguageEnglish */, "match parent").addText("Persian" /* LanguagePersian */, "\u0645\u0637\u0627\u0628\u0642 \u0648\u0627\u0644\u062F")
      );
      this.addReservedValue(
        new RuntimeElementAttributeValue("justify-all").addText("English" /* LanguageEnglish */, "justify all").addText("Persian" /* LanguagePersian */, "\u062A\u0631\u0627\u0632 \u0647\u0645\u0647")
      );
    }
  };

  // runtime/attribute/content.ts
  var RuntimeGlobalAttributeContent = class extends RuntimeElementAttribute {
    constructor() {
      super("AnyNoEmpty" /* AnyNoEmpty */, void 0);
      this.addText("Persian" /* LanguagePersian */, "\u0645\u062D\u062A\u0648\u0627");
      this.addText("English" /* LanguageEnglish */, "content");
    }
  };

  // runtime/attribute/id.ts
  var RuntimeGlobalAttributeId = class extends RuntimeElementAttribute {
    constructor() {
      super("AnyNoEmpty" /* AnyNoEmpty */, "id");
      this.addText("Persian" /* LanguagePersian */, "\u0634\u0646\u0627\u0633\u0647 \u06CC\u06A9\u062A\u0627");
      this.addText("English" /* LanguageEnglish */, "id");
    }
  };

  // runtime/attribute/class.ts
  var RuntimeGlobalAttributeClass = class extends RuntimeElementAttribute {
    constructor() {
      super("AnyNoEmpty" /* AnyNoEmpty */, "class");
      this.addText("Persian" /* LanguagePersian */, "\u0634\u0646\u0627\u0633\u0647");
      this.addText("English" /* LanguageEnglish */, "class");
    }
  };

  // runtime/attribute/custom/repeat.ts
  var RuntimeGlobalAttributeRepeat = class extends RuntimeElementAttribute {
    constructor() {
      super("PositiveInt" /* PositiveInt */, void 0);
      this.addText("Persian" /* LanguagePersian */, "\u062A\u06A9\u0631\u0627\u0631");
      this.addText("English" /* LanguageEnglish */, "repeat");
    }
  };

  // runtime/element_style_state.ts
  var RuntimeElementStyleState = class {
    generate_name;
    text;
    attributes;
    // We are not using it at the moment.
    constructor(generate_name) {
      this.generate_name = generate_name;
      this.text = /* @__PURE__ */ new Map();
      this.attributes = [];
    }
    addText(languageId, value) {
      if (!this.text.has(languageId)) {
        this.text.set(languageId, []);
      }
      this.text.get(languageId).push(value);
      return this;
    }
    getText(languageId) {
      return this.text.get(languageId);
    }
  };

  // runtime/style/state/active.ts
  var RuntimeElementStyleStateActive = class extends RuntimeElementStyleState {
    constructor() {
      super("active");
      this.addText("Persian" /* LanguagePersian */, "\u0641\u0639\u0627\u0644");
      this.addText("English" /* LanguageEnglish */, "active");
    }
  };

  // runtime/style/state/blank.ts
  var RuntimeElementStyleStateBlank = class extends RuntimeElementStyleState {
    constructor() {
      super("blank");
      this.addText("Persian" /* LanguagePersian */, "\u062E\u0627\u0644\u06CC");
      this.addText("English" /* LanguageEnglish */, "blank");
    }
  };

  // runtime/style/state/checked.ts
  var RuntimeElementStyleStateChecked = class extends RuntimeElementStyleState {
    constructor() {
      super("checked");
      this.addText("Persian" /* LanguagePersian */, "\u0627\u0646\u062A\u062E\u0627\u0628 \u0634\u062F\u0647");
      this.addText("English" /* LanguageEnglish */, "checked");
    }
  };

  // runtime/style/state/disabled.ts
  var RuntimeElementStyleStateDisabled = class extends RuntimeElementStyleState {
    constructor() {
      super("disabled");
      this.addText("Persian" /* LanguagePersian */, "\u063A\u06CC\u0631\u0641\u0639\u0627\u0644");
      this.addText("English" /* LanguageEnglish */, "disabled");
    }
  };

  // runtime/style/state/empty.ts
  var RuntimeElementStyleStateEmpty = class extends RuntimeElementStyleState {
    constructor() {
      super("empty");
      this.addText("Persian" /* LanguagePersian */, "\u062E\u0627\u0644\u06CC");
      this.addText("English" /* LanguageEnglish */, "empty");
    }
  };

  // runtime/style/state/enabled.ts
  var RuntimeElementStyleStateEnabled = class extends RuntimeElementStyleState {
    constructor() {
      super("enabled");
      this.addText("Persian" /* LanguagePersian */, "\u0641\u0639\u0627\u0644");
      this.addText("English" /* LanguageEnglish */, "enabled");
    }
  };

  // runtime/style/state/first-child.ts
  var RuntimeElementStyleStateFirstChild = class extends RuntimeElementStyleState {
    constructor() {
      super("first-child");
      this.addText("Persian" /* LanguagePersian */, "\u0627\u0648\u0644\u06CC\u0646 \u0641\u0631\u0632\u0646\u062F");
      this.addText("English" /* LanguageEnglish */, "first-child");
    }
  };

  // runtime/style/state/first-of-type.ts
  var RuntimeElementStyleStateFirstOfType = class extends RuntimeElementStyleState {
    constructor() {
      super("first-of-type");
      this.addText("Persian" /* LanguagePersian */, "\u0627\u0648\u0644\u06CC\u0646 \u0627\u0632 \u0646\u0648\u0639");
      this.addText("English" /* LanguageEnglish */, "first-of-type");
    }
  };

  // runtime/style/state/focus-visible.ts
  var RuntimeElementStyleStateFocusVisible = class extends RuntimeElementStyleState {
    constructor() {
      super("focus-visible");
      this.addText("Persian" /* LanguagePersian */, "\u0642\u0627\u0628\u0644\u06CC\u062A \u062A\u0645\u0631\u06A9\u0632");
      this.addText("English" /* LanguageEnglish */, "focus visible");
    }
  };

  // runtime/style/state/focus-within.ts
  var RuntimeElementStyleStateFocusWithin = class extends RuntimeElementStyleState {
    constructor() {
      super("focus-within");
      this.addText("Persian" /* LanguagePersian */, "\u062F\u0631 \u062F\u0627\u062E\u0644 \u062A\u0645\u0631\u06A9\u0632");
      this.addText("English" /* LanguageEnglish */, "focus within");
    }
  };

  // runtime/style/state/focus.ts
  var RuntimeElementStyleStateFocus = class extends RuntimeElementStyleState {
    constructor() {
      super("focus");
      this.addText("Persian" /* LanguagePersian */, "\u0641\u0648\u06A9\u0648\u0633");
      this.addText("English" /* LanguageEnglish */, "focus");
    }
  };

  // runtime/style/state/global.ts
  var RuntimeElementStyleStateGlobal = class extends RuntimeElementStyleState {
    constructor() {
      super("*");
      this.addText("Persian" /* LanguagePersian */, "\u0633\u0631\u0627\u0633\u0631\u06CC");
      this.addText("English" /* LanguageEnglish */, "global");
    }
  };

  // runtime/style/state/hover.ts
  var RuntimeElementStyleStateHover = class extends RuntimeElementStyleState {
    constructor() {
      super("hover");
      this.addText("Persian" /* LanguagePersian */, "\u0647\u0627\u0648\u0631");
      this.addText("English" /* LanguageEnglish */, "hover");
    }
  };

  // runtime/style/state/in-range.ts
  var RuntimeElementStyleStateInRange = class extends RuntimeElementStyleState {
    constructor() {
      super("in-range");
      this.addText("Persian" /* LanguagePersian */, "\u062F\u0631 \u0645\u062D\u062F\u0648\u062F\u0647");
      this.addText("English" /* LanguageEnglish */, "in-range");
    }
  };

  // runtime/style/state/last-child.ts
  var RuntimeElementStyleStateLastChild = class extends RuntimeElementStyleState {
    constructor() {
      super("last-child");
      this.addText("Persian" /* LanguagePersian */, "\u0622\u062E\u0631\u06CC\u0646 \u0641\u0631\u0632\u0646\u062F");
      this.addText("English" /* LanguageEnglish */, "last-child");
    }
  };

  // runtime/style/state/last-of-type.ts
  var RuntimeElementStyleStateLastOfType = class extends RuntimeElementStyleState {
    constructor() {
      super("last-of-type");
      this.addText("Persian" /* LanguagePersian */, "\u0622\u062E\u0631\u06CC\u0646 \u0627\u0632 \u0646\u0648\u0639");
      this.addText("English" /* LanguageEnglish */, "last-of-type");
    }
  };

  // runtime/style/state/link.ts
  var RuntimeElementStyleStateLink = class extends RuntimeElementStyleState {
    constructor() {
      super("link");
      this.addText("Persian" /* LanguagePersian */, "\u067E\u06CC\u0648\u0646\u062F");
      this.addText("English" /* LanguageEnglish */, "link");
    }
  };

  // runtime/style/state/nth-child.ts
  var RuntimeElementStyleStateNthChild = class extends RuntimeElementStyleState {
    constructor() {
      super("nth-child");
      this.addText("Persian" /* LanguagePersian */, "\u0627\u0646\u062A\u062E\u0627\u0628 \u062F\u0644\u062E\u0648\u0627\u0647 \u0627\u0632 \u0641\u0631\u0632\u0646\u062F");
      this.addText("English" /* LanguageEnglish */, "nth-child");
    }
  };

  // runtime/style/state/nth-last-child.ts
  var RuntimeElementStyleStateNthLastChild = class extends RuntimeElementStyleState {
    constructor() {
      super("nth-last-child");
      this.addText("Persian" /* LanguagePersian */, "\u0627\u0646\u062A\u062E\u0627\u0628 \u062F\u0644\u062E\u0648\u0627\u0647 \u0627\u0632 \u0622\u062E\u0631\u06CC\u0646 \u0641\u0631\u0632\u0646\u062F");
      this.addText("English" /* LanguageEnglish */, "nth-last-child");
    }
  };

  // runtime/style/state/nth-last-of-type.ts
  var RuntimeElementStyleStateNthLastOfType = class extends RuntimeElementStyleState {
    constructor() {
      super("nth-last-of-type");
      this.addText("Persian" /* LanguagePersian */, "\u0627\u0646\u062A\u062E\u0627\u0628 \u062F\u0644\u062E\u0648\u0627\u0647 \u0627\u0632 \u0622\u062E\u0631\u06CC\u0646 \u0646\u0648\u0639");
      this.addText("English" /* LanguageEnglish */, "nth-last-of-type");
    }
  };

  // runtime/style/state/nth-of-type.ts
  var RuntimeElementStyleStateNthOfType = class extends RuntimeElementStyleState {
    constructor() {
      super("nth-of-type");
      this.addText("Persian" /* LanguagePersian */, "\u0627\u0646\u062A\u062E\u0627\u0628 \u062F\u0644\u062E\u0648\u0627\u0647 \u0627\u0632 \u0646\u0648\u0639");
      this.addText("English" /* LanguageEnglish */, "nth-of-type");
    }
  };

  // runtime/style/state/only-child.ts
  var RuntimeElementStyleStateOnlyChild = class extends RuntimeElementStyleState {
    constructor() {
      super("only-child");
      this.addText("Persian" /* LanguagePersian */, "\u062A\u0646\u0647\u0627 \u0641\u0631\u0632\u0646\u062F");
      this.addText("English" /* LanguageEnglish */, "only-child");
    }
  };

  // runtime/style/state/only-of-type.ts
  var RuntimeElementStyleStateOnlyOfType = class extends RuntimeElementStyleState {
    constructor() {
      super("only-of-type");
      this.addText("Persian" /* LanguagePersian */, "\u062A\u0646\u0647\u0627 \u0627\u0632 \u0646\u0648\u0639");
      this.addText("English" /* LanguageEnglish */, "only-of-type");
    }
  };

  // runtime/style/state/optional.ts
  var RuntimeElementStyleStateOptional = class extends RuntimeElementStyleState {
    constructor() {
      super("optional");
      this.addText("Persian" /* LanguagePersian */, "\u0627\u062E\u062A\u06CC\u0627\u0631\u06CC");
      this.addText("English" /* LanguageEnglish */, "optional");
    }
  };

  // runtime/style/state/root.ts
  var RuntimeElementStyleStateRoot = class extends RuntimeElementStyleState {
    constructor() {
      super("root");
      this.addText("Persian" /* LanguagePersian */, "\u0631\u06CC\u0634\u0647");
      this.addText("English" /* LanguageEnglish */, "root");
    }
  };

  // runtime/style/state/target.ts
  var RuntimeElementStyleStateTarget = class extends RuntimeElementStyleState {
    constructor() {
      super("target");
      this.addText("Persian" /* LanguagePersian */, "\u0647\u062F\u0641");
      this.addText("English" /* LanguageEnglish */, "target");
    }
  };

  // runtime/style/state/valid.ts
  var RuntimeElementStyleStateValid = class extends RuntimeElementStyleState {
    constructor() {
      super("valid");
      this.addText("Persian" /* LanguagePersian */, "\u0645\u0639\u062A\u0628\u0631");
      this.addText("English" /* LanguageEnglish */, "valid");
    }
  };

  // runtime/style/state/visited.ts
  var RuntimeElementStyleStateVisited = class extends RuntimeElementStyleState {
    constructor() {
      super("visited");
      this.addText("Persian" /* LanguagePersian */, "\u0628\u0627\u0632\u062F\u06CC\u062F \u0634\u062F\u0647");
      this.addText("English" /* LanguageEnglish */, "visited");
    }
  };

  // runtime/style_element.ts
  var RuntimeStyleElement = class extends RuntimeElement {
    constructor(is_mother, generate_name) {
      super(is_mother, generate_name);
    }
  };

  // runtime/style/element/font.ts
  var RuntimeStyleElementFont = class extends RuntimeStyleElement {
    constructor() {
      super(true, "font");
      this.addText("English" /* LanguageEnglish */, "font");
      this.addText("Persian" /* LanguagePersian */, "\u0641\u0648\u0646\u062A");
      this.addBelongsTo(new RuntimeElementLayout());
      this.addAttribute(
        new RuntimeElementAttribute("FontSrc" /* FontSrc */, "src").addText("Persian" /* LanguagePersian */, "\u0645\u0646\u0628\u0639").addText("English" /* LanguageEnglish */, "source").setStyle()
      );
      this.addAttribute(
        new RuntimeElementAttribute("AnyNoEmpty" /* AnyNoEmpty */, "font-family").addText("Persian" /* LanguagePersian */, "\u0646\u0627\u0645").addText("English" /* LanguageEnglish */, "name").setOutputType("UrlWithFont" /* UrlWithFont */).setStyle().setRequired()
      );
      this.addAttribute(
        new RuntimeElementAttribute("AnyNoEmpty" /* AnyNoEmpty */, "font-style").addText("Persian" /* LanguagePersian */, "\u0627\u0633\u062A\u0627\u06CC\u0644").addText("English" /* LanguageEnglish */, "style").setStyle()
      );
      this.addAttribute(
        new RuntimeElementAttribute("AnyNoEmpty" /* AnyNoEmpty */, "font-weight").addText("Persian" /* LanguagePersian */, "\u0648\u0632\u0646").addText("English" /* LanguageEnglish */, "weight").setStyle()
      );
      this.addAttribute(
        new RuntimeElementAttribute("AnyNoEmpty" /* AnyNoEmpty */, "font-stretch").addText("Persian" /* LanguagePersian */, "\u06A9\u0634\u06CC\u062F\u06AF\u06CC").addText("English" /* LanguageEnglish */, "stretch").setStyle()
      );
      this.addAttribute(
        new RuntimeElementAttribute("AnyNoEmpty" /* AnyNoEmpty */, "unicode-range").addText("Persian" /* LanguagePersian */, "\u0645\u062D\u062F\u0648\u062F\u0647 \u06CC\u0648\u0646\u06CC\u06A9\u062F").addText("English" /* LanguageEnglish */, "unicode range").setStyle()
      );
      this.addAttribute(
        new RuntimeElementAttribute("AnyNoEmpty" /* AnyNoEmpty */, "font-variant").addText("Persian" /* LanguagePersian */, "\u0646\u0648\u0639 \u0641\u0648\u0646\u062A").addText("English" /* LanguageEnglish */, "variant").setStyle()
      );
      this.addAttribute(
        new RuntimeElementAttribute("AnyNoEmpty" /* AnyNoEmpty */, "font-feature-settings").addText("Persian" /* LanguagePersian */, "\u062A\u0646\u0638\u06CC\u0645\u0627\u062A \u0648\u06CC\u0698\u06AF\u06CC \u0641\u0648\u0646\u062A").addText("English" /* LanguageEnglish */, "feature settings").setStyle()
      );
      this.addAttribute(
        new RuntimeElementAttribute("AnyNoEmpty" /* AnyNoEmpty */, "font-variation-settings").addText("Persian" /* LanguagePersian */, "\u062A\u0646\u0638\u06CC\u0645\u0627\u062A \u062A\u063A\u06CC\u06CC\u0631 \u0641\u0648\u0646\u062A").addText("English" /* LanguageEnglish */, "variation settings").setStyle()
      );
    }
  };

  // runtime/runtime.ts
  var runtimeElements = [
    new RuntimeElementLayout(),
    new RuntimeElementA(),
    new RuntimeElementInclude(),
    new RuntimeElementDiv()
  ];
  var runtimeStyleAttributes = [
    new RuntimeStyleAccentColor(),
    new RuntimeStyleAll(),
    new RuntimeStyleAnimationComposition(),
    new RuntimeStyleAnimationDelay(),
    new RuntimeStyleAnimationDirection(),
    new RuntimeStyleAnimationDuration(),
    new RuntimeStyleAnimationFillMode(),
    new RuntimeStyleAnimationIterationCount(),
    new RuntimeStyleAnimationName(),
    new RuntimeStyleAnimationPlayState(),
    new RuntimeStyleAnimationTimingFunction(),
    new RuntimeStyleAppearance(),
    new RuntimeStyleAspectRation(),
    new RuntimeStyleBackdropFilter(),
    new RuntimeStyleBackfaceVisibility(),
    new RuntimeStyleBackgroundColor(),
    new RuntimeStyleBlockSize(),
    new RuntimeStyleBottom(),
    new RuntimeStyleCaptionSide(),
    new RuntimeStyleCaretColor(),
    new RuntimeStyleClear(),
    new RuntimeStyleColor(),
    new RuntimeStyleFontSize(),
    new RuntimeStyleFontFamily(),
    new RuntimeStyleTextAlign()
  ];
  var runtimeGlobalMotherAttributes = [
    new RuntimeGlobalAttributeContent()
  ];
  var runtimeGlobalSingleAttributes = [];
  var runtimeGlobalAttributes = [
    new RuntimeGlobalAttributeId(),
    new RuntimeGlobalAttributeClass(),
    new RuntimeGlobalAttributeRepeat()
  ];
  var runtimeStyleStates = [
    new RuntimeElementStyleStateActive(),
    new RuntimeElementStyleStateBlank(),
    new RuntimeElementStyleStateChecked(),
    new RuntimeElementStyleStateDisabled(),
    new RuntimeElementStyleStateEmpty(),
    new RuntimeElementStyleStateEnabled(),
    new RuntimeElementStyleStateFirstChild(),
    new RuntimeElementStyleStateFirstOfType(),
    new RuntimeElementStyleStateFocusVisible(),
    new RuntimeElementStyleStateFocusWithin(),
    new RuntimeElementStyleStateFocus(),
    new RuntimeElementStyleStateGlobal(),
    new RuntimeElementStyleStateHover(),
    new RuntimeElementStyleStateInRange(),
    new RuntimeElementStyleStateLastChild(),
    new RuntimeElementStyleStateLastOfType(),
    new RuntimeElementStyleStateLink(),
    new RuntimeElementStyleStateNthChild(),
    new RuntimeElementStyleStateNthLastChild(),
    new RuntimeElementStyleStateNthLastOfType(),
    new RuntimeElementStyleStateNthOfType(),
    new RuntimeElementStyleStateOnlyChild(),
    new RuntimeElementStyleStateOnlyOfType(),
    new RuntimeElementStyleStateOptional(),
    new RuntimeElementStyleStateRoot(),
    new RuntimeElementStyleStateTarget(),
    new RuntimeElementStyleStateValid(),
    new RuntimeElementStyleStateVisited()
  ];
  var runtimeStyleElements = [
    new RuntimeStyleElementFont()
  ];

  // phase/validator/validation/validator.ts
  var Validator = class _Validator {
    constructor(ast) {
      this.ast = ast;
      this.errors = [];
      this.symbol_table = new SymbolTable();
      this.extendedFunctions = {};
      this.extendedVariables = {};
      this.packages = {};
      this.packageFunctions = [];
    }
    pushPackage(name, type) {
      this.packages[name] = type;
    }
    pushExtendedFunction(name, type) {
      this.extendedFunctions[name] = type;
    }
    pushExtendedVariable(name, type) {
      this.extendedVariables[name] = type;
    }
    pushError(message) {
      this.errors.push(message);
    }
    static findInCollection(languageId, collection, name, filterFn) {
      return collection.find((item) => {
        if (!item.getText(languageId)?.includes(name)) return false;
        return filterFn ? filterFn(item) : true;
      });
    }
    static findElementRuntime(languageId, parent_element, name) {
      let parent_runtime_element = void 0;
      if (parent_element !== void 0) {
        parent_runtime_element = _Validator.getElementRuntime(languageId, void 0, parent_element.enduser_name);
      }
      return _Validator.findInCollection(languageId, runtimeElements, name, (runtimeElementItem) => {
        if (!parent_element) {
          return true;
        }
        return runtimeElementItem.belongs_to.length === 0 || parent_runtime_element === void 0 || runtimeElementItem.belongs_to.some(
          (element) => element.constructor.name === parent_element.constructor.name
        );
      });
    }
    static findStyleElementRuntime(languageId, parent_element, name) {
      let parent_runtime_element = void 0;
      if (parent_element !== void 0) {
        parent_runtime_element = _Validator.getElementRuntime(languageId, void 0, parent_element.enduser_name);
      }
      return _Validator.findInCollection(languageId, runtimeStyleElements, name, (runtimeElementItem) => {
        if (!parent_element) {
          return true;
        }
        return runtimeElementItem.belongs_to.length === 0 || parent_runtime_element === void 0 || runtimeElementItem.belongs_to.some(
          (element) => element.constructor.name === parent_runtime_element.constructor.name
        );
      });
    }
    static getElementStyleStateRuntime(languageId, parent_element, name) {
      return _Validator.findInCollection(languageId, runtimeStyleStates, name, (runtimeStyleStateItem) => {
        if (!parent_element) {
          return true;
        }
        const value = runtimeStyleStateItem.getText(languageId);
        return value ? true : false;
      });
    }
    static getElementRuntime(languageId, parent_element, name) {
      return _Validator.findElementRuntime(languageId, parent_element, name);
    }
    static getStyleElementRuntime(languageId, parent_element, name) {
      return _Validator.findStyleElementRuntime(languageId, parent_element, name);
    }
    static hasElementRuntime(languageId, parent_element, name) {
      return _Validator.findElementRuntime(languageId, parent_element, name) !== void 0;
    }
    static getElementAttributeRuntime(languageId, element, key) {
      return _Validator.findInCollection(languageId, element.attributes, key);
    }
    static hasElementAttributeRuntime(languageId, element, key) {
      return _Validator.getElementAttributeRuntime(languageId, element, key) !== void 0;
    }
    static executeChecks(checks) {
      return checks.reduce(
        (result, check) => result || check(),
        void 0
      );
    }
    static getElementAttributeStyle(languageId, name) {
      return _Validator.findInCollection(languageId, runtimeStyleAttributes, name);
    }
    static getElementAllAttributeRuntime(languageId, runtimeElement, attribute_name) {
      const checks = [
        () => _Validator.getElementAttributeRuntime(languageId, runtimeElement, attribute_name),
        () => _Validator.findInCollection(languageId, runtimeStyleAttributes, attribute_name),
        () => runtimeElement.is_mother ? _Validator.findInCollection(languageId, runtimeGlobalMotherAttributes, attribute_name) : _Validator.findInCollection(languageId, runtimeGlobalSingleAttributes, attribute_name),
        () => _Validator.findInCollection(languageId, runtimeGlobalAttributes, attribute_name)
      ];
      return _Validator.executeChecks(checks);
    }
    static hasElementAllAttributeRuntime(languageId, runtimeElement, attribute_name) {
      return _Validator.getElementAllAttributeRuntime(languageId, runtimeElement, attribute_name) !== void 0;
    }
    getLanguageId() {
      return this.ast.language.id;
    }
    writeToFile(fileName) {
      let fs;
      if (typeof window === "undefined") {
        fs = import("fs");
      } else {
        return;
      }
      try {
        fs.writeFileSync(fileName, this.ast.stringify(true), "utf-8");
      } catch (error) {
        if (error instanceof Error) {
          this.pushError(validatorMessageRenderer(
            this.getLanguageId(),
            "VALIDATOR_SAVE_OUTPUT_ERROR" /* VALIDATOR_SAVE_OUTPUT_ERROR */,
            fileName,
            error.message
          ));
        } else {
          this.pushError(validatorMessageRenderer(
            this.getLanguageId(),
            "VALIDATOR_SAVE_OUTPUT_ERROR" /* VALIDATOR_SAVE_OUTPUT_ERROR */,
            fileName,
            "An unknown error occurred"
          ));
        }
      }
    }
  };

  // phase/parser/parse/layout/attribute.ts
  function parserParseLayoutAttribute(parser, element_enduser_name, attribute_key_tokens) {
    if (attribute_key_tokens.length === 0) {
      parser.pushError(parserMessageRenderer(parser.getLanguageId(), "PARSER_UNEXPECTED_END_OF_TOKENS_IN_LAYOUT_ATTRIBUTE" /* PARSER_UNEXPECTED_END_OF_TOKENS_IN_LAYOUT_ATTRIBUTE */));
    }
    const attribute_key = arrayName2String(attribute_key_tokens);
    const attribute_value = parserParseLayoutAttributeValue(parser, element_enduser_name, attribute_key);
    if (!attribute_value) {
      return void 0;
    }
    const isStyle = Validator.getElementAttributeStyle(parser.getLanguageId(), attribute_key);
    const attribute_kind = isStyle ? "Style" /* Style */ : "Normal" /* Normal */;
    const attribute = new AstLayoutAttribute(element_enduser_name, attribute_key, attribute_value, attribute_kind);
    return attribute;
  }

  // phase/parser/parse/layout/element.ts
  function parserParseLayoutElement(parser, element_key_tokens) {
    const element_key = arrayName2String(element_key_tokens);
    const element = new AstLayoutElement(element_key);
    while (parser.index < parser.lexer.tokens.length) {
      if (parser.currentToken.type === "BLOCK_END" /* TOKEN_BLOCK_END */ || parser.currentToken.type === "EOF" /* TOKEN_EOF */) {
        break;
      }
      if (parser.currentToken.isKeyword) {
        const key_tokens = parserParseLayoutKey(parser);
        if (parser.skip("ASSIGN" /* TOKEN_ASSIGN */)) {
          const attribute = parserParseLayoutAttribute(parser, element_key, key_tokens);
          if (attribute) {
            if (attribute.isStyle()) {
              if (!element.styles.push(attribute)) {
                parser.pushError(parserMessageRenderer(parser.getLanguageId(), "PARSER_DUPLICATE_STYLE_ATTRIBUTE_IN_LAYOUT" /* PARSER_DUPLICATE_STYLE_ATTRIBUTE_IN_LAYOUT */, attribute.key));
                return void 0;
              }
            } else {
              if (!element.attributes.push(attribute)) {
                parser.pushError(parserMessageRenderer(parser.getLanguageId(), "PARSER_DUPLICATE_ELEMENT_ATTRIBUTE_IN_LAYOUT" /* PARSER_DUPLICATE_ELEMENT_ATTRIBUTE_IN_LAYOUT */, attribute.key));
                return void 0;
              }
            }
          }
        } else if (parser.skipBlockOpen()) {
          const sub_element = parserParseLayoutElement(parser, key_tokens);
          if (!sub_element) {
            parser.pushError(parserMessageRenderer(parser.getLanguageId(), "PARSER_UNEXPECTED_TOKEN_AS_ELEMENT_NAME" /* PARSER_UNEXPECTED_TOKEN_AS_ELEMENT_NAME */, parser.currentToken.type));
            return void 0;
          }
          element.block.push(sub_element);
        } else {
          parser.pushError(parserMessageRenderer(parser.getLanguageId(), "PARSER_UNEXPECTED_TOKEN_IN_LAYOUT" /* PARSER_UNEXPECTED_TOKEN_IN_LAYOUT */, parser.currentToken.type));
          return void 0;
        }
      } else {
        parser.pushError(parserMessageRenderer(parser.getLanguageId(), "PARSER_UNEXPECTED_TOKEN_IN_LAYOUT_AS_ATTRIBUTE" /* PARSER_UNEXPECTED_TOKEN_IN_LAYOUT_AS_ATTRIBUTE */, parser.currentToken.type));
        return void 0;
      }
    }
    parser.expectBlockClose();
    return element;
  }

  // phase/parser/parse/layout/layout.ts
  function parserParseLayout(parser, parent_block) {
    const token = parser.currentToken;
    parser.expect("LAYOUT" /* TOKEN_LAYOUT */);
    parser.expectBlockOpen();
    const element = parserParseLayoutElement(parser, [token]);
    if (!element) {
      return void 0;
    }
    const ast = new AstLayout(element);
    return ast;
  }

  // phase/parser/parse/ast/block.ts
  var AstBlock = class extends AstNode {
    constructor() {
      super("Block");
      this.children = [];
      this.symbol_table = new SymbolTable();
      this.parent_block = void 0;
    }
    setParentBlock(parent_block) {
      this.parent_block = parent_block;
    }
    addChild(node) {
      this.children.push(node);
    }
    lookUp(name) {
      let currentBlock = this;
      while (currentBlock) {
        const symbol = currentBlock.symbol_table.getSymbol(name);
        if (symbol !== void 0) {
          return symbol;
        }
        currentBlock = currentBlock.parent_block;
      }
      return void 0;
    }
    stringify(wantsJson = true) {
      const obj = {
        children: this.children
        // symbol_table: this.symbol_table.stringify(false),
      };
      return stringify(obj, wantsJson);
    }
  };

  // phase/parser/parse/ast/statement/statement.ts
  var AstStatement = class extends AstNode {
    constructor(type) {
      super(type);
    }
  };

  // phase/parser/parse/ast/statement/print.ts
  var AstStatementPrint = class extends AstStatement {
    constructor(value) {
      super("Print");
      this.value = value;
    }
  };

  // phase/parser/parse/statement/print.ts
  function parseStatementPrint(parser) {
    const token = parser.currentToken;
    parser.expect("PRINT" /* TOKEN_PRINT */);
    if (token.data === void 0) {
      return void 0;
    }
    const expression = parseExpression(parser);
    if (expression === void 0) {
      parser.pushError(parserMessageRenderer(parser.getLanguageId(), "PARSER_EXPRESSION_EXPECTED_IN_STATEMENT" /* PARSER_EXPRESSION_EXPECTED_IN_STATEMENT */, token.data.getValueString()));
      return void 0;
    }
    const ast = new AstStatementPrint(expression);
    return ast;
  }

  // phase/parser/parse/ast/statement/return.ts
  var AstStatementReturn = class extends AstStatement {
    constructor(value) {
      super("Return");
      this.value = value;
    }
  };

  // phase/parser/parse/statement/return.ts
  function parseStatementReturn(parser) {
    const token = parser.currentToken;
    parser.expect("RET" /* TOKEN_RET */);
    if (token.data === void 0) {
      return void 0;
    }
    const expression = parseExpression(parser);
    if (expression === void 0) {
      parser.pushError(parserMessageRenderer(parser.getLanguageId(), "PARSER_EXPRESSION_EXPECTED_IN_STATEMENT" /* PARSER_EXPRESSION_EXPECTED_IN_STATEMENT */, token.data.getValueString()));
      return void 0;
    }
    const ast = new AstStatementReturn(expression);
    return ast;
  }

  // phase/parser/parse/ast/statement/expression.ts
  var AstStatementExpression = class extends AstStatement {
    constructor(value) {
      super("Expression");
      this.value = value;
    }
  };

  // phase/parser/parse/statement/expression.ts
  function parseStatementExpression(parser) {
    const expression = parseExpression(parser);
    if (expression === void 0) {
      return void 0;
    }
    const ast = new AstStatementExpression(expression);
    return ast;
  }

  // phase/parser/parse/expression/type.ts
  function parseType(parser) {
    const token = parser.currentToken;
    if (!isDataTypeToken(token) || token.data === void 0) {
      parser.pushError("Expected type, but is not valid!");
      return void 0;
    }
    const ast = new AstType(token.type.replace("DATA_TYPE_", "").toLowerCase());
    parser.next();
    return ast;
  }

  // phase/parser/parse/ast/statement/expression_declaration.ts
  var AstStatementExpressionDeclaration = class extends AstStatement {
    constructor(value_type, name, value) {
      super("ExpressionDeclaration");
      this.value_type = value_type;
      this.name = name;
      this.value = value;
    }
  };

  // phase/parser/parse/statement/expression_declaration.ts
  function parseStatementExpressionDeclaration(parser) {
    const type = parseType(parser);
    if (type === void 0) {
      return void 0;
    }
    const name = parser.expectGet("IDENTIFIER" /* TOKEN_IDENTIFIER */);
    if (name === void 0 || name.data === void 0) {
      return void 0;
    }
    parser.expect("ASSIGN" /* TOKEN_ASSIGN */);
    const value = parseExpression(parser);
    if (value === void 0) {
      return void 0;
    }
    const ast = new AstStatementExpressionDeclaration(type, name.data.getValueString(), value);
    return ast;
  }

  // phase/parser/parse/ast/statement/if.ts
  var AstStatementIf = class extends AstNode {
    constructor(condition, thenBranch, elseBranch) {
      super("If");
      this.condition = condition;
      this.thenBranch = thenBranch;
      if (elseBranch !== void 0) {
        this.elseBranch = elseBranch;
      } else {
        this.elseBranch = void 0;
      }
    }
    stringify(wantsJson = true) {
      const obj = {
        condition: this.condition,
        thenBranch: this.thenBranch,
        elseBranch: this.elseBranch
      };
      return stringify(obj, wantsJson);
    }
  };

  // phase/parser/parse/statement/if.ts
  function parseStatementIf(parser) {
    parser.expect("IF" /* TOKEN_IF */);
    const condition = parseExpression(parser);
    if (condition === void 0) {
      return void 0;
    }
    const true_block = parserParseBlock(parser);
    if (true_block === void 0) {
      return void 0;
    }
    const false_block = void 0;
    const ast = new AstStatementIf(condition, true_block, false_block);
    return ast;
  }

  // phase/parser/parse/ast/statement/defer.ts
  var AstStatementDefer = class extends AstNode {
    constructor(statement) {
      super("Defer");
      this.statement = statement;
    }
    stringify(wantsJson = true) {
      const obj = {
        statement: this.statement
      };
      return stringify(obj, wantsJson);
    }
  };

  // phase/parser/parse/statement/defer.ts
  function parseStatementDefer(parser) {
    parser.expect("DEFER" /* TOKEN_DEFER */);
    if (parser.has("DEFER" /* TOKEN_DEFER */)) {
      parser.pushError("Cannot have another defer staement after defer keyword!");
      return void 0;
    }
    const statement = parseStatement(parser);
    if (statement === void 0) {
      parser.pushError("error: statement defer needs a statement after defer keyword");
      return void 0;
    }
    const ast = new AstStatementDefer(statement);
    return ast;
  }

  // phase/parser/parse/statement/statement.ts
  function parseStatement(parser) {
    const current_token = parser.currentToken;
    switch (current_token.type) {
      case "RET": {
        return parseStatementReturn(parser);
      }
      case "PRINT": {
        return parseStatementPrint(parser);
      }
      case "IF": {
        return parseStatementIf(parser);
      }
      case "DEFER": {
        return parseStatementDefer(parser);
      }
      default: {
        if (isDataTypeToken(current_token)) {
          return parseStatementExpressionDeclaration(parser);
        } else {
          return parseStatementExpression(parser);
        }
      }
    }
    return void 0;
  }

  // phase/parser/parse/block.ts
  function parserParseBlock(parser) {
    const ast = new AstBlock();
    parser.expectBlockOpen();
    while (!parser.isBlockClose()) {
      const statement = parseStatement(parser);
      if (statement === void 0) {
        parser.pushError(parserMessageRenderer(parser.getLanguageId(), "PARSER_STATEMENT_IS_NOT_VALID_IN_BLOCK" /* PARSER_STATEMENT_IS_NOT_VALID_IN_BLOCK */));
        return void 0;
      }
      ast.addChild(statement);
    }
    parser.expectBlockClose();
    return ast;
  }

  // phase/parser/parse/ast/function/function_argument.ts
  var AstFunctionArgument = class extends AstNode {
    constructor(name, value_type, is_optional = false) {
      super("FunctionArgument");
      this.name = name;
      this.value_type = value_type;
      this.is_optional = is_optional;
    }
  };

  // phase/parser/parse/function/function_attributes.ts
  function parserParseFunctionArguments(parser) {
    const args = [];
    if (!parser.skip("LEFT_PAREN" /* TOKEN_LEFT_PAREN */)) {
      return args;
    }
    while (!parser.isEnd) {
      if (parser.currentToken.type === "RIGHT_PAREN" /* TOKEN_RIGHT_PAREN */) {
        break;
      }
      const type = parseType(parser);
      const token = parser.currentToken;
      if (type === void 0) {
        parser.pushError("function attribute type is not valid!");
        return void 0;
      }
      if (!token.isKeyword || token.data === void 0) {
        parser.pushError("we expect attribute name for the function, but is invalid.");
        return void 0;
      }
      const name = token.data.getValueString();
      parser.next();
      const argument = new AstFunctionArgument(name, type);
      args.push(argument);
    }
    parser.expect("RIGHT_PAREN" /* TOKEN_RIGHT_PAREN */);
    return args;
  }

  // phase/parser/parse/ast/function/function_declaration.ts
  var AstFunctionDeclaration = class extends AstNode {
    constructor(name, args, body, return_type) {
      super("FunctionDeclaration");
      this.name = name;
      this.args = args;
      this.body = body;
      this.return_type = return_type;
    }
    stringify(wantsJson = true) {
      const obj = {
        name: this.name,
        args: this.args,
        body: this.body.stringify(false),
        return_type: this.return_type.stringify(false)
      };
      return stringify(obj, wantsJson);
    }
  };

  // phase/parser/parse/function/function_declaration.ts
  function parserParseFunctionDeclaration(parser, parent_block) {
    parser.expect("FN" /* TOKEN_FN */);
    if (!parser.currentToken.isKeyword) {
      parser.pushError(parserMessageRenderer(parser.getLanguageId(), "PARSER_FUNCTION_NAME_IS_NOT_VALID_IDENTIFIER" /* PARSER_FUNCTION_NAME_IS_NOT_VALID_IDENTIFIER */));
      return void 0;
    } else if (parser.currentToken.isDefinedIdentifier) {
      parser.pushError(parserMessageRenderer(parser.getLanguageId(), "PARSER_FUNCTION_NAME_IS_RESERVED_IN_SALAM" /* PARSER_FUNCTION_NAME_IS_RESERVED_IN_SALAM */));
      return void 0;
    }
    const name = parser.currentToken.data?.getValueString();
    if (name === void 0) {
      parser.pushError(parserMessageRenderer(parser.getLanguageId(), "PARSER_FUNCTION_NAME_IS_NOT_VALID" /* PARSER_FUNCTION_NAME_IS_NOT_VALID */));
      return void 0;
    }
    parser.next();
    const params = parserParseFunctionArguments(parser);
    if (!params) {
      parser.pushError(parserMessageRenderer(parser.getLanguageId(), "PARSER_FUNCTION_PARAMETERS_ARE_NOT_VALID" /* PARSER_FUNCTION_PARAMETERS_ARE_NOT_VALID */));
      return void 0;
    }
    let return_type = void 0;
    if (parser.skip("TOKEN_MEMBER_POINTER" /* TOKEN_MEMBER_POINTER */)) {
      return_type = parseType(parser);
      if (return_type === void 0) {
        parser.pushError("Invalid data type as return type of function " + name);
        return void 0;
      }
    }
    if (return_type === void 0) {
      return_type = AstType.createVoid();
    }
    const body = parserParseBlock(parser);
    if (!body) {
      parser.pushError(parserMessageRenderer(parser.getLanguageId(), "PARSER_FUNCTION_BODY_IS_NOT_VALID" /* PARSER_FUNCTION_BODY_IS_NOT_VALID */));
      return void 0;
    }
    const ast = new AstFunctionDeclaration(name, params, body, return_type);
    return ast;
  }

  // phase/parser/parse/parse.ts
  function parse(parser) {
    while (parser.index < parser.lexer.tokens.length) {
      const token = parser.lexer.tokens[parser.index];
      if (token.type === "EOF" /* TOKEN_EOF */) {
        break;
      } else if (token.type === "FN" /* TOKEN_FN */) {
        const function_declaration = parserParseFunctionDeclaration(parser, parser.ast.block);
        if (!function_declaration) {
          parser.pushError(parserMessageRenderer(parser.getLanguageId(), "PARSER_FAILED_TO_PARSE_FUNCTION_STATEMENT" /* PARSER_FAILED_TO_PARSE_FUNCTION_STATEMENT */));
          break;
        }
        if (!parser.ast.pushFunctionDeclaration(function_declaration)) {
          parser.pushError(parserMessageRenderer(parser.getLanguageId(), "PARSER_FAILED_TO_PARSE_FUNCTION" /* PARSER_FAILED_TO_PARSE_FUNCTION */));
          break;
        }
      } else if (token.type === "LAYOUT" /* TOKEN_LAYOUT */) {
        const layout = parserParseLayout(parser, parser.ast.block);
        if (!layout) {
          parser.pushError(parserMessageRenderer(parser.getLanguageId(), "PARSER_FAILED_TO_PARSE_LAYOUT_ELEMENT" /* PARSER_FAILED_TO_PARSE_LAYOUT_ELEMENT */));
          break;
        }
        if (!parser.ast.setLayout(layout)) {
          parser.pushError(parserMessageRenderer(parser.getLanguageId(), "PARSER_DUPLICATE_LAYOUT_DEFINITION" /* PARSER_DUPLICATE_LAYOUT_DEFINITION */));
          break;
        }
      } else {
        parser.pushError(parserMessageRenderer(parser.getLanguageId(), "PARSER_UNEXPECTED_TOKEN_IN_PROGRAM" /* PARSER_UNEXPECTED_TOKEN_IN_PROGRAM */, token.type));
        break;
      }
    }
  }

  // runtime/block/runtime_bock.ts
  var RuntimeBlock = class {
    static generate() {
      const block = new AstBlock();
      const math_type = AstType.createPackage();
      math_type.setSyetem();
      const math_sin_type = AstType.createFunction("sin", "sin", [new AstFunctionArgument("value", AstType.createFloat())], AstType.createFloat());
      math_sin_type.setSyetem();
      math_type.addMember(math_sin_type);
      const math_cos_type = AstType.createFunction("cos", "cos", [new AstFunctionArgument("value", AstType.createFloat())], AstType.createFloat());
      math_cos_type.setSyetem();
      math_type.addMember(math_cos_type);
      const math_tan_type = AstType.createFunction("tan", "tan", [new AstFunctionArgument("value", AstType.createFloat())], AstType.createFloat());
      math_tan_type.setSyetem();
      math_type.addMember(math_tan_type);
      const math_creator_type = AstType.createMemberValue("creator", AstType.createString());
      math_type.addMember(math_creator_type);
      math_type.setSyetem();
      block.symbol_table.addSystemSymbol("math", math_type);
      const pi_type = AstType.createFloat();
      pi_type.setSyetem();
      block.symbol_table.addSystemSymbol("pi", pi_type);
      const version_type = AstType.createString();
      version_type.setSyetem();
      block.symbol_table.addSystemSymbol("version", version_type);
      const int2str_type = AstType.createFunction("int2str", "int2str", [new AstFunctionArgument("value", AstType.createInt())], AstType.createString());
      int2str_type.setSyetem();
      block.symbol_table.addSystemSymbol("int2str", int2str_type);
      const float2str_type = AstType.createFunction("float2str", "float2str", [new AstFunctionArgument("value", AstType.createFloat())], AstType.createString());
      float2str_type.setSyetem();
      block.symbol_table.addSystemSymbol("float2str", float2str_type);
      const memory_alloc_type = AstType.createFunction("malloc", "malloc", [new AstFunctionArgument("size", AstType.createSize())], AstType.createPointer());
      memory_alloc_type.setSyetem();
      block.symbol_table.addSystemSymbol("malloc", memory_alloc_type);
      const memory_realloc_type = AstType.createFunction("realloc", "realloc", [new AstFunctionArgument("pointer", AstType.createPointer()), new AstFunctionArgument("size", AstType.createSize())], AstType.createPointer());
      memory_realloc_type.setSyetem();
      block.symbol_table.addSystemSymbol("realloc", memory_realloc_type);
      const free_type = AstType.createFunction("free", "free", [new AstFunctionArgument("pointer", AstType.createPointer())], AstType.createVoid());
      free_type.setSyetem();
      block.symbol_table.addSystemSymbol("free", free_type);
      const strdup_type = AstType.createFunction("strdup", "strdup", [new AstFunctionArgument("value", AstType.createString())], AstType.createVoid());
      strdup_type.setSyetem();
      block.symbol_table.addSystemSymbol("strdup", strdup_type);
      const strcpy_type = AstType.createFunction("strcpy", "strcpy", [new AstFunctionArgument("pointer", AstType.createPointer()), new AstFunctionArgument("value", AstType.createString())], AstType.createVoid());
      strcpy_type.setSyetem();
      block.symbol_table.addSystemSymbol("strcpy", strcpy_type);
      const strcat_type = AstType.createFunction("strcat", "strcat", [new AstFunctionArgument("target", AstType.createString()), new AstFunctionArgument("append", AstType.createString())], AstType.createVoid());
      strcat_type.setSyetem();
      block.symbol_table.addSystemSymbol("strcat", strcat_type);
      return block;
    }
  };

  // phase/parser/parse/ast/program.ts
  var AstProgram = class extends AstNode {
    constructor(language, block = void 0) {
      super("Program");
      this.errors = [];
      this.functions = [];
      this.language = language;
      if (block === void 0) {
        this.block = RuntimeBlock.generate();
      } else {
        this.block = block;
      }
    }
    hasLayout() {
      if (this.layout !== void 0) {
        return true;
      }
      return false;
    }
    setLayout(layout) {
      if (this.hasLayout()) {
        return false;
      }
      this.layout = layout;
      return true;
    }
    hasFunctionDeclaration(function_declaration) {
      return false;
    }
    pushFunctionDeclaration(function_declaration) {
      if (this.hasFunctionDeclaration(function_declaration)) {
        return false;
      }
      this.functions.push(function_declaration);
      return true;
    }
    pushError(error) {
      this.errors.push(error);
    }
    stringify(wantsJson = true) {
      const obj = {
        type: this.type,
        functions: this.functions.map((f) => f.stringify(false)),
        layout: this.layout?.stringify(false),
        errors: this.errors,
        language: this.language
      };
      return stringify(obj, wantsJson);
    }
  };

  // phase/parser/parse/parser.ts
  var Parser = class {
    constructor(lexer) {
      this.ast = new AstProgram(lexer.language);
      this.lexer = lexer;
      this.index = 0;
    }
    get isEnd() {
      return this.index >= this.lexer.tokens.length || this.currentToken.type === "EOF" /* TOKEN_EOF */;
    }
    get currentToken() {
      return this.lexer.tokens[this.index];
    }
    get nextToken() {
      if (this.index + 1 >= this.lexer.tokens.length) {
        return void 0;
      }
      return this.lexer.tokens[this.index + 1];
    }
    get previousToken() {
      if (this.index - 1 < 0) {
        return void 0;
      }
      return this.lexer.tokens[this.index - 1];
    }
    hasPrevious(tokenType) {
      return this.previousToken?.type === tokenType;
    }
    hasNext(tokenType) {
      return this.nextToken?.type === tokenType;
    }
    has(tokenType) {
      return this.currentToken.type === tokenType;
    }
    expectGet(tokenType) {
      if (this.has(tokenType)) {
        this.index++;
        return this.previousToken;
      }
      this.pushError(parserMessageRenderer(this.lexer.language.id, "PARSER_EXPECTED_TOKEN_DATA_TYPE_BUT_GOT" /* PARSER_EXPECTED_TOKEN_DATA_TYPE_BUT_GOT */, tokenType, this.currentToken.type));
      return void 0;
    }
    expect(tokenType) {
      if (this.has(tokenType)) {
        this.index++;
        return true;
      }
      this.pushError(parserMessageRenderer(this.lexer.language.id, "PARSER_EXPECTED_TOKEN_DATA_TYPE_BUT_GOT" /* PARSER_EXPECTED_TOKEN_DATA_TYPE_BUT_GOT */, tokenType, this.currentToken.type));
      return false;
    }
    skip(tokenType) {
      if (this.has(tokenType)) {
        this.index++;
        return true;
      }
      return false;
    }
    next() {
      if (this.index !== this.lexer.tokens.length) {
        this.index++;
      }
    }
    previous() {
      if (this.index !== 0) {
        this.index--;
      }
    }
    pushError(message) {
      this.ast.pushError(message);
    }
    skipBlockOpen() {
      return this.skip("COLON" /* TOKEN_COLON */);
    }
    skipBlockClose() {
      return this.skip("BLOCK_END" /* TOKEN_BLOCK_END */);
    }
    expectBlockOpen() {
      this.expect("COLON" /* TOKEN_COLON */);
    }
    expectBlockClose() {
      this.expect("BLOCK_END" /* TOKEN_BLOCK_END */);
    }
    isBlockClose() {
      return this.has("BLOCK_END" /* TOKEN_BLOCK_END */);
    }
    isBlockOpen() {
      return this.has("COLON" /* TOKEN_COLON */);
    }
    stringify(wantsJson = true) {
      return stringify(this.ast, wantsJson);
    }
    getLanguageId() {
      return this.ast.language.id;
    }
  };

  // common/cli/run/parser.ts
  function processCommandRunParser(fileName, absoluteDirPath, source, selectedLanguage) {
    const lexer = new Lexer(source, selectedLanguage, fileName, absoluteDirPath);
    lex(lexer);
    const parser = new Parser(lexer);
    parse(parser);
    if (typeof window !== "undefined") {
      window.lexer = lexer;
      window.parser = parser;
    }
    if (!checkError(parser, void 0, void 0)) {
      return 1;
    }
    if (typeof window === "undefined") {
      console.log(parser.stringify());
    }
    return 0;
  }

  // phase/validator/validation/is-url.ts
  function isUrl(url) {
    try {
      new URL(url);
      return true;
    } catch (_) {
      return false;
    }
  }

  // phase/validator/validation/layout/element_attribute_value.ts
  function validateLayoutElementAttributeValue(validator, attribute, runtimeElementAttribute) {
    const attr_name = runtimeElementAttribute.getText(validator.getLanguageId())?.join(" ") || "Unknown Attribute";
    const value = attribute.value.getString();
    const error = validatorMessageRenderer(validator.getLanguageId(), "VALIDATOR_ATTRIBUTE_VALUE_NOT_VALID" /* VALIDATOR_ATTRIBUTE_VALUE_NOT_VALID */, value, runtimeElementAttribute.type, attr_name, attribute.element_enduser_name);
    if (runtimeElementAttribute.type !== "String" /* String */ && value === "") {
      return validatorMessageRenderer(validator.getLanguageId(), "VALIDATOR_ATTRIBUTE_VALUE_NOT_EMPTY" /* VALIDATOR_ATTRIBUTE_VALUE_NOT_EMPTY */, attr_name, attribute.element_enduser_name);
    }
    switch (runtimeElementAttribute.type) {
      case "Url" /* Url */: {
        if (isUrl(value)) {
          return void 0;
        } else {
          return error;
        }
      }
      case "Urls" /* Urls */: {
        return void 0;
      }
      case "Strings" /* Strings */: {
        return void 0;
      }
      case "FontSrc" /* FontSrc */: {
        const extenstions = [".woff", ".woff2", ".ttf", ".otf", ".eot", ".svg"];
        if (!extenstions.some((ext) => value.endsWith(ext))) {
          return error;
        }
        attribute.output_type = "UrlWithFont" /* UrlWithFont */;
        return void 0;
      }
      case "String" /* String */: {
        if (value === "") {
          return void 0;
        }
        return error;
      }
      case "StringNoEmpty" /* StringNoEmpty */: {
        return error;
      }
      case "Sizes" /* Sizes */: {
        return void 0;
      }
      case "Size" /* Size */: {
        return void 0;
      }
      case "PositiveInt" /* PositiveInt */: {
        if (isNaN(Number(value)) || Number(value) < 0) {
          return error;
        }
        return void 0;
      }
      case "IDs" /* IDs */: {
        return void 0;
      }
      case "ID" /* ID */: {
        return void 0;
      }
      case "CSSMedia" /* CSSMedia */: {
        return void 0;
      }
      case "Coords" /* Coords */: {
        const coords = value.split(",");
        if (coords.length !== 2) {
          return error;
        } else if (isNaN(Number(coords[0])) || isNaN(Number(coords[1]))) {
          return error;
        }
        return void 0;
      }
      case "Color" /* Color */: {
        if (value.startsWith("#") === true) {
          if (value.length !== 7 && value.length !== 4 || !/^#[0-9A-F]{6}$/i.test(value)) {
            return error;
          } else {
            return void 0;
          }
        }
        return error;
      }
      case "Colors" /* Colors */: {
        return void 0;
      }
      case "Number" /* Number */: {
        if (isNaN(Number(value))) {
          return error;
        }
        return void 0;
      }
      case "Boolean" /* Boolean */: {
        if (value !== "true" && value !== "false") {
          return error;
        }
        return void 0;
      }
      case "Date" /* Date */: {
        const datePattern = /^\d{4}-\d{2}-\d{2}$/;
        if (!datePattern.test(value) || isNaN(Date.parse(value))) {
          return error;
        }
        return void 0;
      }
      case "Time" /* Time */: {
        const timePattern = /^([01]?[0-9]|2[0-3]):([0-5][0-9])$/;
        if (!timePattern.test(value) || isNaN(Date.parse(`1970-01-01T${value}:00Z`))) {
          return error;
        }
        return void 0;
      }
      case "Times" /* Times */: {
      }
      case "DateTime" /* DateTime */: {
        const dateTimePattern = /^\d{4}-\d{2}-\d{2}T([01]?[0-9]|2[0-3]):([0-5][0-9]):([0-5][0-9])$/;
        if (!dateTimePattern.test(value) || isNaN(Date.parse(value))) {
          return error;
        }
        return void 0;
      }
      case "NumberOr2Numbers" /* NumberOr2Numbers */: {
        const parts = value.split(" ");
        if (parts.length > 2) {
          return error;
        }
        for (const part of parts) {
          if (isNaN(Number(part))) {
            return error;
          }
        }
        return void 0;
      }
    }
  }

  // phase/validator/validation/layout/element_attribute_reserved_value.ts
  function validateLayoutElementAttributeReservedValue(validator, attribute, runtimeElementAttribute) {
    const error = validatorMessageRenderer(validator.getLanguageId(), "VALIDATOR_ATTRIBUTE_RESERVED_VALUE_NOT_VALID" /* VALIDATOR_ATTRIBUTE_RESERVED_VALUE_NOT_VALID */, attribute.value.getString(), attribute.enduser_name, attribute.element_enduser_name);
    if (runtimeElementAttribute.reservedValues.length > 0) {
      const found = runtimeElementAttribute.reservedValues.find((value) => value.getText(validator.getLanguageId())?.includes(attribute.value.getString()));
      if (!found) {
        return error;
      }
      attribute.generate_value = found.generate_name;
      attribute.generate_type = found.constructor.name;
      return void 0;
    }
    return error;
  }

  // phase/validator/validation/layout/element_style_state_attribute.ts
  function validateLayoutElementStyleStateAttribute(validator, runtime_element_style_state, attribute, element, main_element) {
    const element_name = element.enduser_name;
    const attribute_name = attribute.enduser_name;
    const runtimeElementAttribute = Validator.getElementAttributeStyle(validator.getLanguageId(), attribute_name);
    if (runtimeElementAttribute === void 0) {
      validator.pushError(validatorMessageRenderer(validator.getLanguageId(), "VALIDATOR_ATTRIBUTE_NOT_VALID" /* VALIDATOR_ATTRIBUTE_NOT_VALID */, attribute_name, element_name));
      return;
    }
    attribute.kind = runtimeElementAttribute.kind;
    attribute.generate_name = runtimeElementAttribute.generate_name;
    attribute.generate_type = runtimeElementAttribute.constructor.name;
    const error_reserved_value = validateLayoutElementAttributeReservedValue(validator, attribute, runtimeElementAttribute);
    if (error_reserved_value !== void 0) {
      const error_validate = validateLayoutElementAttributeValue(validator, attribute, runtimeElementAttribute);
      if (error_validate !== void 0) {
        validator.pushError(error_validate);
      }
    }
  }

  // phase/validator/validation/layout/element_style_state_attributes.ts
  function validateLayoutElementStyleStateAttributes(validator, element_enduser_name, runtime_element_style_state, element, main_element) {
    for (const attribute of element.styles.items) {
      validateLayoutElementStyleStateAttribute(validator, runtime_element_style_state, attribute, element, main_element);
    }
  }

  // phase/validator/validation/layout/element_style_state.ts
  function validateLayoutElementStyleState(validator, parent_element, element, element_style_state = void 0) {
    if (element_style_state === void 0) {
      element_style_state = Validator.getElementStyleStateRuntime(validator.getLanguageId(), parent_element, element.enduser_name);
      if (element_style_state === void 0) {
        validator.pushError(validatorMessageRenderer(validator.getLanguageId(), "VALIDATOR_ELEMENT_STYLE_STATE_NOT_VALID" /* VALIDATOR_ELEMENT_STYLE_STATE_NOT_VALID */, element.enduser_name));
        return;
      }
    }
    element.generate_name = element_style_state.generate_name;
    element.kind = "StyleState" /* StyleState */;
    element.generate_type = element_style_state.constructor.name;
    element.built_in_selector = parent_element?.built_in_selector;
    validateLayoutElementStyleStateAttributes(validator, element.enduser_name, element_style_state, element, parent_element);
  }

  // phase/validator/validation/layout/element_or_state.ts
  function validateLayoutElementOrState(validator, parent_block, parent_element, element) {
    const runtime_element = Validator.getElementRuntime(validator.getLanguageId(), parent_element, element.enduser_name);
    if (runtime_element !== void 0) {
      validateLayoutElement(validator, parent_block, parent_element, element, runtime_element);
      return;
    }
    const runtime_style_element = Validator.getStyleElementRuntime(validator.getLanguageId(), parent_element, element.enduser_name);
    if (runtime_style_element !== void 0) {
      validateLayoutElement(validator, parent_block, parent_element, element, runtime_style_element);
      return;
    }
    const runtimeStyleState = Validator.getElementStyleStateRuntime(validator.getLanguageId(), parent_element, element.enduser_name);
    if (runtimeStyleState !== void 0) {
      validateLayoutElementStyleState(validator, parent_element, element, runtimeStyleState);
    } else {
      validator.pushError(validatorMessageRenderer(validator.getLanguageId(), "VALIDATOR_ELEMENT_OR_STYLE_STATE_NOT_VALID" /* VALIDATOR_ELEMENT_OR_STYLE_STATE_NOT_VALID */, element.enduser_name));
    }
  }

  // phase/validator/validation/layout/block.ts
  function validateLayoutBlock(validator, parent_block, parent_element, element, block) {
    for (const item of block.items) {
      validateLayoutElementOrState(validator, parent_block, element, item);
    }
  }

  // phase/validator/validation/layout/element_attribute.ts
  function validateLayoutElementAttribute(validator, runtimeElement, attribute, element) {
    const element_name = element.enduser_name;
    const attribute_name = attribute.enduser_name;
    const runtimeElementAttribute = Validator.getElementAllAttributeRuntime(validator.getLanguageId(), runtimeElement, attribute_name);
    if (runtimeElementAttribute === void 0) {
      validator.pushError(validatorMessageRenderer(validator.getLanguageId(), "VALIDATOR_ATTRIBUTE_NOT_VALID" /* VALIDATOR_ATTRIBUTE_NOT_VALID */, attribute_name, element_name));
      return;
    }
    attribute.kind = runtimeElementAttribute.kind;
    attribute.generate_name = runtimeElementAttribute.generate_name;
    attribute.generate_type = runtimeElementAttribute.constructor.name;
    attribute.is_hide = runtimeElementAttribute.is_hide;
    if (attribute.generate_type === "RuntimeGlobalAttributeContent") {
      element.content = attribute.value.getString().trim();
      if (element.content === "") {
        element.content = void 0;
      }
    } else {
      const error_reserved_value = validateLayoutElementAttributeReservedValue(validator, attribute, runtimeElementAttribute);
      if (error_reserved_value !== void 0) {
        const error_validate = validateLayoutElementAttributeValue(validator, attribute, runtimeElementAttribute);
        if (error_validate !== void 0) {
          validator.pushError(error_validate);
        }
      }
    }
    if (attribute.generate_type === "RuntimeGlobalAttributeRepeat") {
      element.repeat = parseInt(attribute.value.getString());
    }
  }

  // phase/validator/validation/layout/element_attributes.ts
  function validateLayoutElementAttributes(validator, element_enduser_name, runtime_element, element) {
    for (const attribute of element.attributes.items) {
      validateLayoutElementAttribute(validator, runtime_element, attribute, element);
    }
    for (const runtimeAttribute of runtime_element.attributes) {
      if (runtimeAttribute.is_required && runtimeAttribute.generate_name !== void 0) {
        const foundAttributes = element.attributes.getByGenerateName(runtimeAttribute.generate_name);
        if (foundAttributes === void 0) {
          const attribute_name = runtimeAttribute.getText(validator.getLanguageId())?.join(" ") || "Unknown Attribute";
          validator.pushError(validatorMessageRenderer(validator.getLanguageId(), "VALIDATOR_ATTRIBUTE_REQUIRED" /* VALIDATOR_ATTRIBUTE_REQUIRED */, attribute_name, element_enduser_name));
        }
      }
    }
    for (const attribute of element.attributes.items) {
      if (attribute.generate_name !== void 0 && !Validator.hasElementAllAttributeRuntime(validator.getLanguageId(), runtime_element, attribute.enduser_name)) {
        validator.pushError(validatorMessageRenderer(validator.getLanguageId(), "VALIDATOR_ATTRIBUTE_NOT_SUPPORTED" /* VALIDATOR_ATTRIBUTE_NOT_SUPPORTED */, attribute.enduser_name, element_enduser_name));
      }
    }
    if (element.styles.items.length > 0) {
      if (element.built_in_selector === void 0) {
        element.generateBuiltInSelector(validator);
      }
      for (const attribute of element.styles.items) {
        validateLayoutElementAttribute(validator, runtime_element, attribute, element);
      }
    }
  }

  // phase/validator/validation/layout/element.ts
  function validateLayoutElement(validator, parent_block, parent_element, element, runtime_element = void 0) {
    if (runtime_element === void 0) {
      runtime_element = Validator.getElementRuntime(validator.getLanguageId(), parent_element, element.enduser_name);
      if (runtime_element === void 0) {
        runtime_element = Validator.getStyleElementRuntime(validator.getLanguageId(), parent_element, element.enduser_name);
      }
      if (runtime_element === void 0) {
        validator.pushError(validatorMessageRenderer(validator.getLanguageId(), "VALIDATOR_ELEMENT_NOT_VALID" /* VALIDATOR_ELEMENT_NOT_VALID */, element.enduser_name));
        return;
      }
    }
    element.generate_name = runtime_element.generate_name;
    element.generate_type = runtime_element.constructor.name;
    validateLayoutElementAttributes(validator, element.enduser_name, runtime_element, element);
    validateLayoutBlock(validator, parent_block, parent_element, element, element.block);
  }

  // phase/validator/validation/layout/layout.ts
  function validateLayout(validator, parent_block, layout) {
    validateLayoutElement(validator, parent_block, void 0, layout.root);
  }

  // phase/validator/validation/expression/unary.ts
  function validateExpressionUnary(validator, block, expr) {
    validateExpression(validator, block, expr.right);
  }

  // phase/validator/validation/expression/binary.ts
  function validateExpressionBinary(validator, block, expr) {
    validateExpression(validator, block, expr.left);
    const left_type = expr.left.value_type?.getType();
    if (left_type === void 0) {
      return;
    }
    if (expr.operator === "MEMBER" /* TOKEN_MEMBER */) {
      if (!left_type.isPackage && !left_type.isStruct) {
        validator.pushError("Cannot apply member operator on a value which is not a package or struct, this value is " + left_type.type_kind);
        return;
      }
      if (expr.right.type === "ExpressionVariable") {
        expr.value_type = left_type?.getMember(expr.right.getString());
        if (expr.value_type === void 0) {
          validator.pushError("Member " + expr.right.getString() + " does not exist in the package or struct.");
          return;
        }
        if (left_type.isPackage) {
          expr.generated_value = expr.left.getString() + "_" + expr.right.getString();
          if (expr.value_type !== void 0 && !expr.value_type?.isFunction) {
            validator.pushExtendedVariable(expr.generated_value, expr.value_type);
          }
        } else {
          expr.generated_value = expr.left.getString() + "." + expr.right.getString();
        }
        return;
      } else {
        validator.pushError("Right side of member operator should be an identifier to get an sub element from the package or struct.");
        return;
      }
    } else {
      validateExpression(validator, block, expr.right);
      const right_type = expr.right.value_type?.getType();
      if (right_type === void 0) {
        validator.pushError("Right side of binary expression is not valid");
        return;
      } else if (left_type.isEqual(right_type)) {
        expr.value_type = left_type;
      } else if (expr.operator === "GREATER" /* TOKEN_GREATER */ || expr.operator === "GREATER_EQUAL" /* TOKEN_GREATER_EQUAL */ || expr.operator === "LESS" /* TOKEN_LESS */ || expr.operator === "LESS_EQUAL" /* TOKEN_LESS_EQUAL */) {
        if (left_type.isNumber && right_type.isNumber) {
          expr.value_type = AstType.createBool();
        } else {
          validator.pushError("Binary expression with non-numeric types for comparison is not supported yet");
          return;
        }
      } else if (left_type.isNumber && right_type.isNumber) {
        if (left_type.isFloat || right_type.isFloat) {
          expr.value_type = AstType.createFloat();
        } else {
          expr.value_type = AstType.createInt();
        }
      } else {
        validator.pushError("Binary expression with different types is not supported yet for " + expr.operator);
        return;
      }
    }
  }

  // phase/validator/validation/expression/variable.ts
  function validateExpressionVariable(validator, block, expr) {
    validateExpression(validator, block, expr.left);
    if (expr.left.value_type === void 0) {
      return;
    }
    const name = expr.left.getString();
    const symbol_type = block.lookUp(name);
    if (symbol_type === void 0) {
      validator.pushError(`Variable '${name}' is not defined`);
      return;
    }
    if (symbol_type.isPackage) {
      validator.pushPackage(name, symbol_type);
    }
    expr.value_type = symbol_type;
  }

  // phase/validator/validation/function/function_parameter.ts
  function validateFunctionParameter(validator, block, parameter) {
    validateExpression(validator, block, parameter.value);
  }

  // phase/validator/validation/function/function_parameters.ts
  function validateFunctionParameters(validator, block, attributes) {
    for (const attribute of attributes) {
      validateFunctionParameter(validator, block, attribute);
    }
  }

  // phase/validator/validation/function/function_call.ts
  function validateExpressionFunctionCall(validator, block, node) {
    validateExpression(validator, block, node.left);
    const left_type = node.left.value_type?.getType();
    if (left_type === void 0) {
      return;
    }
    if (left_type.isFunction) {
      validator.pushError("Cannot call an invalid value which is not a real function!");
      return;
    }
    if (node.left.type === "ExpressionBinary") {
      node.generated_value = node.left.generated_value;
    } else if (node.left.type === "ExpressionVariable" && node.left.value_type !== void 0) {
      node.generated_value = node.left.value_type.func_name;
    } else {
      validator.pushError("Cannot detect function name in your expression function call");
    }
    validateFunctionParameters(validator, block, node.parameters);
    if (node.generated_value !== void 0 && node.left.value_type !== void 0 && node.left.value_type.is_system) {
      validator.pushExtendedFunction(node.generated_value, node.left.value_type);
    }
    node.value_type = left_type;
  }

  // phase/validator/validation/expression/expression.ts
  function validateExpression(validator, block, expr) {
    switch (expr.type) {
      case "ExpressionBinary":
        validateExpressionBinary(validator, block, expr);
        break;
      case "ExpressionUnary":
        validateExpressionUnary(validator, block, expr);
        break;
      case "ExpressionVariable":
        validateExpressionVariable(validator, block, expr);
        break;
      case "ExpressionFunctionCall":
        validateExpressionFunctionCall(validator, block, expr);
        break;
    }
  }

  // phase/validator/validation/statement/if.ts
  function validateStatementIf(validator, parent_block, node) {
    validateExpression(validator, parent_block, node.condition);
    validateBlock(validator, parent_block, node.thenBranch);
    if (node.elseBranch !== void 0) {
      validateBlock(validator, parent_block, node.elseBranch);
    }
  }

  // phase/validator/validation/statement/defer.ts
  function validateStatementDefer(validator, parent_block, node) {
    validateStatement(validator, parent_block, node.statement);
  }

  // phase/validator/validation/statement/print.ts
  function validateStatementPrint(validator, block, stmt) {
    validateExpression(validator, block, stmt.value);
  }

  // phase/validator/validation/statement/return.ts
  function validateStatementReturn(validator, block, stmt) {
    validateExpression(validator, block, stmt.value);
  }

  // phase/validator/validation/statement/expression.ts
  function validateStatementExpression(validator, block, stmt) {
    validateExpression(validator, block, stmt.value);
  }

  // phase/validator/validation/expression/type.ts
  function validateType(validator, node) {
  }

  // phase/validator/validation/statement/expression_declaration.ts
  function validateStatementExpressionDeclaration(validator, block, stmt) {
    validateType(validator, stmt.value_type);
    if (stmt.value_type.type_kind === "Void") {
      validator.pushError("Cannot declare a variable of type 'void'.");
      return;
    }
    if (stmt.value !== void 0) {
      validateExpression(validator, block, stmt.value);
    }
    if (!stmt.value?.value_type?.castablle(stmt.value_type)) {
      validator.pushError("Value type does not match variable type in '" + stmt.name + "' var, cannot save " + stmt.value?.value_type?.getString() + " in " + stmt.value_type.getString() + " variable.");
      return;
    }
    if (block.symbol_table.hasSymbol(stmt.name)) {
      validator.pushError(`Variable '${stmt.name}' already declared in this scope.`);
    } else {
      block.symbol_table.addSymbol(stmt.name, stmt.value_type);
    }
  }

  // phase/validator/validation/statement/statement.ts
  function validateStatement(validator, block, stmt) {
    switch (stmt.type) {
      case "Print":
        validateStatementPrint(validator, block, stmt);
        break;
      case "If":
        validateStatementIf(validator, block, stmt);
        break;
      case "Defer":
        validateStatementDefer(validator, block, stmt);
        break;
      case "Return":
        validateStatementReturn(validator, block, stmt);
        break;
      case "Expression":
        validateStatementExpression(validator, block, stmt);
        break;
      case "ExpressionDeclaration":
        validateStatementExpressionDeclaration(validator, block, stmt);
        break;
    }
  }

  // phase/validator/validation/statement/block.ts
  function validateBlock(validator, parent_block, block) {
    if (block.parent_block === void 0 && parent_block !== void 0) {
      block.setParentBlock(parent_block);
    }
    for (const statement of block.children) {
      validateStatement(validator, block, statement);
    }
  }

  // phase/validator/validation/function/function_argument.ts
  function validateFunctionArgument(validator, arg) {
    validateType(validator, arg.value_type);
  }

  // phase/validator/validation/function/function_arguments.ts
  function validateFunctionArguments(validator, parent_block, args) {
    for (const arg of args) {
      validateFunctionArgument(validator, arg);
    }
  }

  // phase/validator/validation/function/function_declaration.ts
  function validateFunctionDeclaration(validator, parent_block, func) {
    const table_func = parent_block.lookUp(func.name);
    if (table_func !== void 0) {
      if (table_func.isFunction) {
        validator.pushError("Another function with the same name is already defiend!");
      } else {
        validator.pushError("Another variable with the same name is already defiend!");
      }
      return;
    }
    validateFunctionArguments(validator, parent_block, func.args);
    for (const argument of func.args) {
      parent_block.symbol_table.addSymbol(argument.name, argument.value_type);
    }
    validateBlock(validator, parent_block, func.body);
    let generated_name = func.name;
    if (validator.ast.language.flag === "fa" && func.name === "\u0627\u0635\u0644\u06CC") {
      generated_name = "main";
    }
    const func_type = AstType.createFunction(func.name, generated_name, func.args, func.return_type);
    parent_block.symbol_table.addSymbol(func.name, func_type);
  }

  // phase/validator/validation/validate.ts
  function validate(validator) {
    validator.ast.functions.forEach((node) => {
      validateFunctionDeclaration(validator, validator.ast.block, node);
    });
    if (validator.ast.layout !== void 0) {
      validateLayout(validator, validator.ast.block, validator.ast.layout);
    }
  }

  // common/cli/run/validator.ts
  function processCommandRunValidator(fileName, absoluteDirPath, source, selectedLanguage) {
    const lexer = new Lexer(source, selectedLanguage, fileName, absoluteDirPath);
    lex(lexer);
    const parser = new Parser(lexer);
    parse(parser);
    if (typeof window !== "undefined") {
      window.lexer = lexer;
      window.parser = parser;
    }
    if (!checkError(parser, void 0, void 0)) {
      return 1;
    }
    const validator = new Validator(parser.ast);
    validate(validator);
    if (typeof window !== "undefined") {
      window.validator = validator;
    }
    if (!checkError(parser, validator, void 0)) {
      return 1;
    }
    return 0;
  }

  // phase/generator/generation/layout/include.ts
  var import_sync_fetch = __toESM(require_browser());

  // base.ts
  var SALAM_VERSION = "1.0.0";

  // phase/generator/generation/expression/type.ts
  function generateTypePrimary(type) {
    if (type.type_kind === "void") {
      return "void";
    } else if (type.type_kind === "int") {
      return "int";
    } else if (type.type_kind === "float") {
      return "float";
    } else if (type.type_kind === "bool") {
      return "bool";
    } else if (type.type_kind === "size") {
      return "size_t";
    } else if (type.type_kind === "pointer") {
      return "void*";
    } else if (type.type_kind === "string") {
      return "char*";
    } else if (type.type_kind === "char") {
      return "char";
    }
    return "undefined_type?";
  }
  function generateType(generator, type) {
    return generateTypePrimary(type);
    let result = "Type_" + type.type_kind;
    if (type.is_pointer) {
      result += "_Pointer";
    }
    if (type.is_reference) {
      result += "_Reference";
    }
    if (type.is_array) {
      result += "_Array";
    }
    return result;
  }

  // phase/generator/generation/statement/function_arguments.ts
  function generateFunctionArguments(generator, args) {
    let result = "";
    for (const argument of args) {
      if (result.length > 0) {
        result += ", ";
      }
      if (argument.value_type !== void 0) {
        const param_type = generateType(generator, argument.value_type);
        result += param_type;
        result += " ";
        result += argument.name;
      }
    }
    return result;
  }

  // phase/generator/generation/generator.ts
  var Generator = class {
    static {
      this.tempVarCounter = 0;
    }
    constructor(ast, extendedFunctions, extendedVariables, packages) {
      this.ast = ast;
      this.errors = [];
      this.indentLevel = 0;
      this.source = "";
      this.source_c = "";
      this.enableLines = true;
      this.styles = [];
      this.functions = [];
      this.sign_functions = [];
      this.libraries = [];
      this.extendedFunctions = extendedFunctions;
      this.extendedVariables = extendedVariables;
      this.packages = packages;
      this.temp = "";
      this.libraries.push("#include <stdio.h>");
      this.libraries.push("#include <stdlib.h>");
      this.libraries.push("#include <string.h>");
      this.libraries.push("#include <stdbool.h>");
      this.libraries.push("#include <math.h>");
      this.libraries.push("#include <time.h>");
      this.libraries.push("#include <ctype.h>");
    }
    static getTempVar() {
      return `temp_var_${this.tempVarCounter++}`;
    }
    setTemp(temp) {
      this.temp = temp;
    }
    getTemp() {
      const temp = this.temp;
      this.setTemp("");
      return temp;
    }
    pushExtendedFunction(name, type) {
      this.extendedFunctions[name] = type;
    }
    pushFunction(func) {
      this.functions.push(func);
    }
    pushSignFunction(func) {
      this.sign_functions.push(func);
    }
    pushStyleTop(style) {
      this.styles.unshift(style);
    }
    pushStyle(style) {
      this.styles.push(style);
    }
    increaseIndent() {
      this.indentLevel++;
    }
    setIndent(level) {
      this.indentLevel = level;
    }
    getIndent() {
      return this.indentLevel;
    }
    decreaseIndent() {
      if (this.indentLevel === 0) {
        this.pushError(generatorMessageRenderer(this.getLanguageId(), "GENERATOR_CANNOT_OUTDENT_BELOW_ZERO" /* GENERATOR_CANNOT_OUTDENT_BELOW_ZERO */));
        return;
      }
      this.indentLevel--;
    }
    //  Buffers a single line of text.
    buffer(line) {
      return line;
    }
    // Buffers a line of text with or without a newline based on `enableLines`.
    bufferLine(line) {
      return this.enableLines ? this.buffer(`${line}
`) : this.buffer(line);
    }
    //  Buffers an indented line without adding a newline.
    bufferIndented(line) {
      const indentation = " ".repeat(this.indentLevel * 4);
      return this.enableLines ? this.buffer(`${indentation}${line}`) : this.buffer(line);
    }
    // Buffers an indented line and adds a newline if `enableLines` is true.
    bufferIndentedLine(line) {
      return this.bufferIndented(`${line}${this.enableLines ? "\n" : ""}`);
    }
    pushError(message) {
      this.errors.push(message);
    }
    getGeneratedSource() {
      return this.source;
    }
    getGeneratedSourceC() {
      let result = "";
      if (this.functions.length === 0) {
        return result;
      }
      result += "// Libraries\n";
      if (this.libraries.length > 0) {
        result += this.libraries.join("\n");
        result += "\n";
        result += "\n";
      }
      const packagesEntries = Object.entries(this.packages);
      if (packagesEntries.length > 0) {
        result += "// External libraries\n";
        for (const [name, value] of packagesEntries) {
          result += "// Import " + name + "\n";
        }
        result += "\n";
      }
      const extendedFunctionsEntries = Object.entries(this.extendedFunctions);
      if (extendedFunctionsEntries.length > 0) {
        result += "// Extended functions\n";
        for (const [name, value] of extendedFunctionsEntries) {
          if (value && value.func_return_type && value.func_args) {
            result += "extern ";
            result += generateType(this, value.func_return_type);
            result += " ";
            result += name;
            result += "(";
            result += generateFunctionArguments(this, value.func_args);
            result += ");\n";
          }
        }
        result += "\n";
      }
      const extendedVariablesEntries = Object.entries(this.extendedVariables);
      if (extendedVariablesEntries.length > 0) {
        result += "// Extended variables\n";
        for (const [name, value] of extendedVariablesEntries) {
          if (value) {
            result += "extern ";
            result += generateType(this, value);
            result += " ";
            result += name;
            result += ";\n";
          }
        }
        result += "\n";
      }
      if (this.sign_functions.length > 0) {
        result += "// Sign functions\n";
        result += this.sign_functions.join("\n");
        result += "\n";
        result += "\n";
      }
      result += "// Functions\n";
      result += this.functions.join("\n");
      return result;
    }
    getLanguageId() {
      return this.ast.language.id;
    }
    stringify(wantsJson = true) {
      return stringify(this, wantsJson);
    }
    writeToFile(fileName) {
      let fs;
      if (typeof window === "undefined") {
        fs = import("fs");
      } else {
        return;
      }
      try {
        fs.writeFileSync(fileName, this.getGeneratedSourceC() + "\n" + this.getGeneratedSource(), "utf-8");
      } catch (error) {
        if (error instanceof Error) {
          this.pushError(generatorMessageRenderer(
            this.getLanguageId(),
            "GENERATOR_SAVE_OUTPUT_ERROR" /* GENERATOR_SAVE_OUTPUT_ERROR */,
            fileName,
            error.message
          ));
        } else {
          this.pushError(generatorMessageRenderer(
            this.getLanguageId(),
            "GENERATOR_SAVE_OUTPUT_ERROR" /* GENERATOR_SAVE_OUTPUT_ERROR */,
            fileName,
            "An unknown error occurred"
          ));
        }
      }
    }
  };

  // phase/generator/generation/layout/include.ts
  function includeLayoutString(generator, source, fileName, absoluteDirPath, params) {
    const _lexer = new Lexer(source, generator.ast.language, fileName, absoluteDirPath);
    lex(_lexer);
    const _parser = new Parser(_lexer);
    parse(_parser);
    checkError(_parser, void 0, void 0);
    const _validator = new Validator(_parser.ast);
    validate(_validator);
    checkError(_parser, _validator, void 0);
    const _generator = new Generator(_validator.ast, _validator.extendedFunctions, _validator.extendedVariables, _validator.packages);
    if (_generator.ast.layout !== void 0) {
      _generator.ast.layout.root.generate_name = "div";
      const result = generateLayoutNode(generator, _generator.ast.layout.root);
      checkError(_parser, _validator, _generator);
      return generator.buffer(result);
    }
    return "";
  }
  function fetchUrlSync(url) {
    try {
      const res = (0, import_sync_fetch.default)(url, {
        headers: { "User-Agent": `Salam/${SALAM_VERSION}` }
      });
      return res.text();
    } catch (error) {
      return "";
    }
  }
  function includeLayout(generator, filePath, params) {
    let fs;
    let path;
    if (typeof window === "undefined") {
      fs = import("fs");
      path = import("path");
    }
    if (isUrl(filePath)) {
      try {
        const source = fetchUrlSync(filePath);
        if (!source) {
          generator.pushError(
            generatorMessageRenderer(
              generator.getLanguageId(),
              "GENERATOR_INCLUDE_HTTP_ERROR" /* GENERATOR_INCLUDE_HTTP_ERROR */,
              filePath
            )
          );
          return "";
        }
        return includeLayoutString(generator, source, "online.salam", process.cwd(), params);
      } catch (error) {
        generator.pushError(
          generatorMessageRenderer(
            generator.getLanguageId(),
            "GENERATOR_INCLUDE_HTTP_ERROR" /* GENERATOR_INCLUDE_HTTP_ERROR */,
            filePath
          )
        );
      }
    } else if (fs && path) {
      if (!filePath) {
        generator.pushError(
          generatorMessageRenderer(
            generator.getLanguageId(),
            "GENERATOR_INCLUDE_FILE_PATH_NOT_PROVIDED" /* GENERATOR_INCLUDE_FILE_PATH_NOT_PROVIDED */
          )
        );
      } else if (!fs.existsSync(filePath)) {
        generator.pushError(
          generatorMessageRenderer(
            generator.getLanguageId(),
            "GENERATOR_INCLUDE_FILE_NOT_FOUND" /* GENERATOR_INCLUDE_FILE_NOT_FOUND */,
            filePath
          )
        );
      } else {
        try {
          const fileName = fs.realpathSync(filePath);
          const absoluteDirPath = fs.realpathSync(path.dirname(filePath));
          const source = fs.readFileSync(fileName, "utf8");
          return includeLayoutString(generator, source, fileName, absoluteDirPath, params);
        } catch (error) {
          generator.pushError(
            generatorMessageRenderer(
              generator.getLanguageId(),
              "GENERATOR_INCLUDE_FILE_READ_ERROR" /* GENERATOR_INCLUDE_FILE_READ_ERROR */,
              filePath
            )
          );
        }
      }
    }
    return "";
  }

  // phase/generator/generation/layout/attribute_output.ts
  function generateLayoutAttributeOutput(generator, attribute) {
    if (attribute.generate_value === void 0) {
      return "";
    }
    const output = attribute.generate_value;
    switch (attribute.output_type) {
      case "Normal" /* Normal */:
        if (output.includes(" ") || /[^a-zA-Z0-9]/.test(output)) {
          return `"${output}"`;
        }
        return output;
      case "UrlWithFont" /* UrlWithFont */:
        const extenstionMappe = {
          ".woff": "woff",
          ".woff2": "woff2",
          ".ttf": "truetype",
          ".otf": "opentype",
          ".eot": "embedded-opentype",
          ".svg": "svg"
        };
        const extenstion = output.split(".").pop() || "";
        const format = extenstionMappe["." + extenstion];
        return `url('${attribute.getValue().replace("'", "")}') format('${format}')`;
      case "Url" /* Url */:
        return `url(${output})`;
    }
    return "";
  }

  // phase/generator/generation/layout/attribute.ts
  function generateLayoutAttribute(generator, attribute) {
    let result = "";
    if (attribute.generate_name === void 0) {
      return "";
    }
    if (attribute.is_hide === true) {
      return "";
    }
    result += attribute.generate_name + (attribute.isStyle() ? ":" : "=");
    if (attribute.generate_value === void 0) {
      attribute.generate_value = attribute.value.getString();
    }
    result += generateLayoutAttributeOutput(generator, attribute);
    return result;
  }

  // phase/generator/generation/layout/attributes.ts
  function generateLayoutAttributes(generator, element) {
    let htmlResult = "";
    let styleResult = "";
    for (const attribute of element.styles.items) {
      const generatedAttribute = generateLayoutAttribute(generator, attribute);
      if (generatedAttribute.length > 0) {
        styleResult += styleResult.length > 0 ? `;${generatedAttribute}` : generatedAttribute;
      }
    }
    if (styleResult.length > 0 && element.built_in_selector !== void 0) {
      const element_selector = element.built_in_selector;
      generator.pushStyle(`${element_selector} {${styleResult}}`);
      const built_in_selector = element.built_in_selector.replace(".", "");
      const attribute_class = element.attributes.getByGenerateName("class");
      if (attribute_class !== void 0) {
        const new_class = attribute_class.value.getString() + " " + built_in_selector;
        attribute_class.value = new AstExpressionLiteral(new_class.trim(), AstType.createString());
      } else {
        const class_runtime = new RuntimeGlobalAttributeClass();
        const class_attribute_key = class_runtime.getText(generator.getLanguageId())?.[0];
        if (class_attribute_key) {
          const class_attribute_value = new AstExpressionLiteral(built_in_selector, AstType.createString());
          const class_attribute = new AstLayoutAttribute(element.enduser_name, class_attribute_key, class_attribute_value, "Normal" /* Normal */);
          class_attribute.generate_name = class_runtime.generate_name;
          element.attributes.push(class_attribute);
        }
      }
    }
    for (const attribute of element.attributes.items) {
      const generatedAttribute = generateLayoutAttribute(generator, attribute);
      if (generatedAttribute.length > 0) {
        htmlResult += htmlResult.length > 0 ? ` ${generatedAttribute}` : generatedAttribute;
      }
    }
    return htmlResult;
  }

  // phase/generator/generation/layout/element.ts
  function generateLayoutElement(generator, element) {
    let result = "";
    const hasTag = element.generate_name !== void 0;
    const closing = `</${element.generate_name}>`;
    if (hasTag) {
      result += generator.bufferIndented(`<${element.generate_name}`);
      const attributes_str1 = generateLayoutAttributes(generator, element);
      if (attributes_str1.length > 0) {
        result += generator.buffer(` `);
        result += generator.buffer(attributes_str1);
      }
      result += generator.buffer(`>`);
    }
    let hasContentOrChild = false;
    if (element.block.length > 0 || element.content !== void 0) {
      hasContentOrChild = true;
    }
    const hasContentWithoutChild = element.content !== void 0 && element.block.length === 0;
    const hasInlineContent = element.content !== void 0 && !element.content.includes("\n");
    const hasMultiOpeningClosing = hasContentOrChild && hasContentWithoutChild && !hasInlineContent;
    const isOnlyInlineText = hasContentWithoutChild && !hasMultiOpeningClosing;
    const emptyContent = element.content === void 0 && element.block.length === 0;
    const writeContent = () => {
      if (element.content !== void 0) {
        if (isOnlyInlineText) {
          result += generator.buffer(element.content);
        } else {
          result += generator.bufferIndentedLine(element.content);
        }
      }
    };
    if (isOnlyInlineText) {
      writeContent();
    } else if (hasContentOrChild) {
      if (hasTag) {
        result += generator.bufferLine("");
        generator.increaseIndent();
      }
      writeContent();
      result += generateLayoutBlock(generator, element, element.block);
      if (hasTag) {
        generator.decreaseIndent();
      }
    }
    if (hasTag) {
      const needsIndentClosing = hasMultiOpeningClosing || !hasContentWithoutChild;
      if (!emptyContent && needsIndentClosing) {
        result += generator.bufferIndentedLine(closing);
      } else {
        result += generator.bufferLine(closing);
      }
    }
    if (element.repeat > 1) {
      result = result.repeat(element.repeat);
    }
    return result;
  }

  // phase/generator/generation/layout/node.ts
  function generateLayoutNode(generator, element) {
    let result = "";
    switch (element.generate_type) {
      case "RuntimeElementLayout": {
        result += generateLayoutElement(generator, element);
        break;
      }
      case "RuntimeElementInclude": {
        const include_path = element.attributes.getByGenerateName("source")?.getValue();
        if (include_path) {
          result += includeLayout(generator, include_path, []);
        }
        break;
      }
      default: {
        generator.pushError(generatorMessageRenderer(generator.getLanguageId(), "GENERATOR_UNKNOWN_ELEMENT_TYPE" /* GENERATOR_UNKNOWN_ELEMENT_TYPE */, element.enduser_name));
        break;
      }
    }
    return result;
  }

  // phase/generator/generation/layout/style_state_attributes.ts
  function generateLayoutStyleStateAttributes(generator, attributes) {
    let styleResult = "";
    for (const attribute of attributes.items) {
      if (attribute.isStyle()) {
        const generatedAttribute = generateLayoutAttribute(generator, attribute);
        if (generatedAttribute.length > 0) {
          styleResult += styleResult.length > 0 ? `;${generatedAttribute}` : generatedAttribute;
        }
      }
    }
    return styleResult;
  }

  // phase/generator/generation/layout/style_element.ts
  function generateLayoutStyleElement(generator, element) {
    switch (element.generate_type) {
      case "RuntimeStyleElementFont": {
        let style = "@font-face {";
        style += generateLayoutStyleStateAttributes(generator, element.attributes);
        style += "}";
        generator.pushStyleTop(style);
        return "";
      }
    }
    return "";
  }

  // phase/generator/generation/layout/element_style_state.ts
  function generateLayoutElementStyleState(generator, element_style_state) {
    let result = "";
    const attributes_str = generateLayoutStyleStateAttributes(generator, element_style_state.styles);
    const element_selector = element_style_state.built_in_selector;
    if (element_selector) {
      result += `${element_selector}:${element_style_state.generate_name} {`;
      result += attributes_str;
      result += "}";
    }
    return result;
  }

  // phase/generator/generation/layout/block.ts
  function generateLayoutBlock(generator, element, block) {
    let result = "";
    for (const item of block.items) {
      if (item.generate_name === void 0) {
        result += generateLayoutNode(generator, item);
      } else if (item.isStateStyle()) {
        const css = generateLayoutElementStyleState(generator, item);
        if (css.length > 0) {
          generator.pushStyle(css);
        }
      } else if (item.isStyleElement()) {
        result += generateLayoutStyleElement(generator, item);
      } else {
        result += generateLayoutElement(generator, item);
      }
    }
    return result;
  }

  // phase/generator/generation/layout/layout.ts
  function generateLayout(generator, layout) {
    generator.setIndent(generator.getIndent() + 2);
    const body_attrs = generateLayoutAttributes(generator, layout.root);
    const body = generateLayoutBlock(generator, layout.root, layout.root.block);
    generator.setIndent(generator.getIndent() - 2);
    let result = "";
    const attribute_dir = layout.root.attributes.getByGenerateName("dir")?.getValue() || "rtl";
    const attribute_lang = layout.root.attributes.getByGenerateName("lang")?.getValue() || "fa-IR";
    const attribute_title = layout.root.attributes.getByGenerateName("title")?.getValue() || "Salam Untitled";
    const attribute_author = layout.root.attributes.getByGenerateName("author")?.getValue();
    const attribute_charset = layout.root.attributes.getByGenerateName("author")?.getValue() || "utf-8";
    result += generator.bufferIndentedLine(`<!doctype html>`);
    result += generator.bufferIndentedLine(`<html dir="${attribute_dir}" lang="${attribute_lang}">`);
    generator.increaseIndent();
    result += generator.bufferIndentedLine(`<head>`);
    generator.increaseIndent();
    result += generator.bufferIndentedLine(`<title>${attribute_title}</title>`);
    result += generator.bufferIndentedLine(`<meta charset="${attribute_charset}">`);
    result += generator.bufferIndentedLine(`<meta name="viewport" content="width=device-width, initial-scale=1">`);
    if (attribute_author) {
      result += generator.bufferIndentedLine(`<meta name="author" content="${attribute_author}">`);
    }
    if (generator.styles.length > 0) {
      result += generator.bufferIndentedLine(`<style>`);
      for (const style of generator.styles) {
        result += generator.bufferIndentedLine(style);
      }
      result += generator.bufferIndentedLine(`</style>`);
    }
    generator.decreaseIndent();
    result += generator.bufferIndentedLine(`</head>`);
    result += generator.bufferIndentedLine(`<body${body_attrs ? " " + body_attrs : ""}>`);
    generator.increaseIndent();
    if (layout.root.content !== void 0) {
      result += generator.bufferIndentedLine(layout.root.content);
    }
    result += body;
    generator.decreaseIndent();
    result += generator.bufferIndentedLine(`</body>`);
    generator.decreaseIndent();
    result += generator.bufferIndentedLine(`</html>`);
    return result;
  }

  // phase/generator/generation/expression/operator.ts
  function generateExpressionOperator(generator, left, op, right = void 0) {
    switch (op) {
      case "PLUS" /* TOKEN_PLUS */:
        if (right === void 0) {
          return left;
        }
        return `${left} + ${right}`;
      case "MINUS" /* TOKEN_MINUS */:
        if (right === void 0) {
          return `-${left}`;
        }
        return `${left} - ${right}`;
      case "MULTIPLY" /* TOKEN_MULTIPLY */:
        if (right === void 0) {
          return left;
        }
        return `${left} * ${right}`;
      case "DIVIDE" /* TOKEN_DIVIDE */:
        if (right === void 0) {
          return left;
        }
        return `${left} / ${right}`;
      case "MOD" /* TOKEN_MODULO */:
        if (right === void 0) {
          return left;
        }
        return `${left} % ${right}`;
      case "POWER" /* TOKEN_POWER */:
        if (right === void 0) {
          return left;
        }
        return `pow(${left}, ${right})`;
      case "MEMBER" /* TOKEN_MEMBER */:
        if (right === void 0) {
          return left;
        }
        return `${left}.${right}`;
    }
    return "Unknown operator " + op;
  }

  // phase/generator/generation/expression/unary.ts
  function generateExpressionUnary(generator, expr) {
    const result = { key: "", value: "" };
    const left = generateExpression(generator, expr.right);
    result.key += left.key;
    const op = generateExpressionOperator(generator, left.value, expr.operator, void 0);
    result.value += op;
    return result;
  }

  // phase/generator/generation/expression/binary.ts
  function generateExpressionBinary(generator, expr) {
    let result = { key: "", value: "" };
    if (expr.generated_value !== void 0) {
      result.value = expr.generated_value;
      return result;
    }
    const left = generateExpression(generator, expr.left);
    result.key = left.key;
    const right = generateExpression(generator, expr.right);
    result.key += right.key;
    if (expr.left.value_type?.isNumber && expr.right.value_type?.isNumber) {
      const op = generateExpressionOperator(generator, left.value, expr.operator, right.value);
      result.value += op;
      return result;
    } else if (expr.left.value_type?.isString && expr.right.value_type?.isString) {
      if (expr.operator === "PLUS" /* TOKEN_PLUS */) {
        const tempVar = Generator.getTempVar();
        let first_key = "";
        let tempVarLeft = "";
        let tempVarRight = "";
        result.key += `char* ${tempVar} = malloc(sizeof(char) * (`;
        if (expr.left.value_type.is_primitive) {
          result.key += expr.left.getString().length;
        } else {
          tempVarLeft = Generator.getTempVar();
          first_key += `char* ${tempVarLeft} = ${left.value};
`;
          result.key += `strlen(${tempVarLeft})`;
        }
        result.key += ` + `;
        if (expr.right.value_type.is_primitive) {
          result.key += expr.right.getString().length;
        } else {
          tempVarRight = Generator.getTempVar();
          first_key += `char* ${tempVarRight} = ${right.value};
`;
          result.key += `strlen(${tempVarRight})`;
        }
        result.key += `) + 1);
`;
        if (tempVarLeft !== "") {
          first_key += `strcpy(${tempVar}, ${tempVarLeft});
`;
        } else {
          result.key += `strcpy(${tempVar}, ${left.value});
`;
        }
        if (tempVarRight !== "") {
          result.key += `strcat(${tempVar}, ${tempVarRight});
`;
        } else {
          result.key += `strcat(${tempVar}, ${right.value});
`;
        }
        result.key = first_key + result.key;
        result.value = tempVar;
        return result;
      } else {
        generator.errors.push(`Binary expression with string types and operator '${expr.operator}' is not supported yet`);
        return result;
      }
    } else {
      generator.errors.push(`Binary expression with non-numeric types is not supported yet`);
      return result;
    }
  }

  // phase/generator/generation/expression/literal.ts
  function generateExpressionLiteral(generator, expr) {
    const value = expr.getString();
    if (expr.value_type.type_kind === "string") {
      return { key: "", value: `"${value}"` };
    } else if (expr.value_type.type_kind === "bool") {
      return { key: "", value };
    } else if (expr.value_type.type_kind === "identifier") {
      return { key: "", value };
    } else if (expr.value_type.type_kind === "int") {
      return { key: "", value };
    } else if (expr.value_type.type_kind === "float") {
      return { key: "", value };
    }
    return { key: "", value: `<...${value}...>` };
  }

  // phase/generator/generation/expression/variable.ts
  function generateExpressionVariable(generator, expr) {
    let result = generateExpression(generator, expr.left);
    return result;
  }

  // phase/generator/generation/function/function_parameter.ts
  function generateFunctionParameter(generator, expr) {
    return generateExpression(generator, expr.value);
  }

  // phase/generator/generation/statement/function_parameters.ts
  function generateFunctionParameters(generator, parameters) {
    let result = { key: "", value: "" };
    for (const parameter of parameters) {
      if (result.value.length > 0) {
        result.value += ", ";
      }
      if (parameter.value.value_type !== void 0) {
        const parameter_pair = generateFunctionParameter(generator, parameter);
        result.key += parameter_pair.key;
        result.value += parameter_pair.value;
      }
    }
    return result;
  }

  // phase/generator/generation/function/function_call.ts
  function generateExpressionFunctionCall(generator, expr) {
    let result = { key: "", value: "" };
    if (expr.value_type === void 0) {
      generator.pushError("Cannot handle a function call which is not detected!");
      return result;
    }
    if (expr.left.type === "ExpressionBinary") {
      result.value += expr.left.getString();
    } else {
      const expr_pair = generateExpression(generator, expr.left);
      result.key += expr_pair.key;
      result.value += expr_pair.value;
    }
    result.value += "(";
    const parameters = generateFunctionParameters(generator, expr.parameters);
    result.key += parameters.key;
    result.value += parameters.value;
    result.value += ")";
    return result;
  }

  // phase/generator/generation/expression/expression.ts
  function generateExpression(generator, expr) {
    switch (expr.type) {
      case "ExpressionLiteral":
        return generateExpressionLiteral(generator, expr);
      case "ExpressionBinary":
        return generateExpressionBinary(generator, expr);
      case "ExpressionUnary":
        return generateExpressionUnary(generator, expr);
      case "ExpressionVariable":
        return generateExpressionVariable(generator, expr);
      case "ExpressionFunctionCall":
        return generateExpressionFunctionCall(generator, expr);
    }
    generator.pushError("Unknown expression type " + expr.type);
    return { key: "", value: "" };
  }

  // phase/generator/generation/statement/print.ts
  function generateStatementPrint(generator, stmt) {
    if (stmt.value.value_type === void 0) {
      generator.pushError("Cannot print value of undefined type");
      return "";
    } else if (stmt.value.value_type.isPackage) {
      generator.pushError("Cannot print value of a package");
      return "";
    }
    const type = stmt.value.value_type.isFunction ? stmt.value.value_type.func_return_type : stmt.value.value_type;
    if (type === void 0 || type.type_kind === void 0) {
      generator.pushError("Cannot print a undefined type value!");
      return "";
    }
    const expr = generateExpression(generator, stmt.value);
    let result = ``;
    result += expr.key;
    result += `printf("`;
    let format = "";
    if (type.type_kind === "string") {
      format = "%s";
    } else if (type.type_kind === "int") {
      format = "%d";
    } else if (type.type_kind === "float") {
      format = "%g";
    } else if (type.type_kind === "bool") {
      format = "%s";
    }
    result += format;
    result += `", `;
    result += expr.value;
    if (type.type_kind === "bool") {
      result += ' ? "true" : "false"';
    }
    result += ");\n";
    return result;
  }

  // phase/generator/generation/statement/return.ts
  function generateStatementReturn(generator, stmt) {
    let result = "";
    if (stmt.value.value_type === void 0) {
      generator.pushError("Cannot return value of undefined type");
      return result;
    } else if (stmt.value.value_type.isPackage) {
      generator.pushError("Cannot return value of a package");
      return result;
    }
    const expr = generateExpression(generator, stmt.value);
    result += expr.key;
    result += `return (`;
    result += expr.value;
    result += ");\n";
    return result;
  }

  // phase/generator/generation/statement/expression.ts
  function generateStatementExpression(generator, stmt) {
    let result = "";
    const expr = generateExpression(generator, stmt.value);
    result += expr.key;
    result += expr.value;
    return result;
  }

  // phase/generator/generation/statement/expression_declaration.ts
  function generateStatementExpressionDeclaration(generator, stmt) {
    let result = "";
    result += generateType(generator, stmt.value_type);
    result += " ";
    result += stmt.name;
    if (stmt.value !== void 0) {
      result += " = ";
      const expr = generateExpression(generator, stmt.value);
      if (stmt.value.value_type?.isString) {
        if (stmt.value.type === "ExpressionBinary") {
          let computeStringLength2 = function(expr2) {
            const leftExpr = generateExpression(generator, expr2.left);
            pre_expr += leftExpr.key;
            let leftLen = "";
            if (expr2.left.type === "ExpressionBinary") {
              leftLen = computeStringLength2(expr2.left);
            } else {
              leftLen = `strlen(${leftExpr.value})`;
            }
            const rightExpr = generateExpression(generator, expr2.right);
            pre_expr += rightExpr.key;
            let rightLen = "";
            if (expr2.right.type === "ExpressionBinary") {
              computeStringLength2(expr2.right);
            } else {
              rightLen = `strlen(${rightExpr.value})`;
            }
            return `${leftLen} + ${rightLen}`;
          }, generateStrcat2 = function(expr2, varName) {
            const leftExpr = generateExpression(generator, expr2.left);
            let strcatCode = "";
            if (expr2.left.type === "ExpressionBinary") {
              strcatCode += generateStrcat2(expr2.left, varName);
            } else {
              if (size_check_counter > 0) {
                strcatCode += `strcpy(${varName}, ${leftExpr.value});
`;
              } else {
                strcatCode += `strcat(${varName}, ${leftExpr.value});
`;
              }
              size_check_counter++;
            }
            const rightExpr = generateExpression(generator, expr2.right);
            if (expr2.right.type === "ExpressionBinary") {
              strcatCode += generateStrcat2(expr2.right, varName);
            } else {
              if (size_check_counter > 0) {
                strcatCode += `strcat(${varName}, ${rightExpr.value});
`;
              } else {
                strcatCode += `strcpy(${varName}, ${rightExpr.value});
`;
              }
              size_check_counter++;
            }
            return strcatCode;
          };
          var computeStringLength = computeStringLength2, generateStrcat = generateStrcat2;
          const stmt_value = stmt.value;
          let pre_expr = "";
          result = pre_expr + result;
          const totalSize = computeStringLength2(stmt_value) + " + 1";
          result += `(char*) malloc(${totalSize});
`;
          result += `if (${stmt.name} == NULL) {
`;
          result += `    printf("Memory allocation failed in ${stmt.name}\\n");
`;
          result += `    exit(1);
`;
          result += `}
`;
          let size_check_counter = 0;
          result += generateStrcat2(stmt_value, stmt.name);
        } else {
          result = expr.key + result;
          result += `(char*) malloc(strlen(${expr.value}) + 1);
`;
          result += `if (${stmt.name} == NULL) {
`;
          result += `    printf("Memory allocation failed in ${stmt.name}\\n");
`;
          result += `    exit(1);
`;
          result += `}
`;
          result += `strcpy(${stmt.name}, ${expr.value});
`;
        }
      } else {
        result = expr.key + result;
        result += expr.value;
        result += ";\n";
      }
    }
    return result;
  }

  // phase/generator/generation/statement/if.ts
  function generateStatementIf(generator, stmt) {
    let result = "";
    result += `if (true) {}
`;
    return result;
  }

  // phase/generator/generation/statement/defer.ts
  function generateStatementDefer(generator, stmt) {
    let result = "";
    result += `// defer return
`;
    return result;
  }

  // phase/generator/generation/statement/statement.ts
  function generateStatement(generator, stmt) {
    switch (stmt.type) {
      case "Print":
        return generateStatementPrint(generator, stmt);
      case "Return":
        return generateStatementReturn(generator, stmt);
      case "If":
        return generateStatementIf(generator, stmt);
      case "Defer":
        return generateStatementDefer(generator, stmt);
      case "Expression":
        return generateStatementExpression(generator, stmt);
      case "ExpressionDeclaration":
        return generateStatementExpressionDeclaration(generator, stmt);
    }
    return "// Unknown statement type: " + stmt.type + "\n";
  }

  // phase/generator/generation/statement/block.ts
  function generateBlock(generator, block) {
    let result = "{\n";
    for (const statement of block.children) {
      result += generateStatement(generator, statement);
    }
    result += "}\n";
    return result;
  }

  // phase/generator/generation/statement/function_declaration.ts
  function generateFunctionDeclaration(generator, func) {
    let result = "";
    let sign = "";
    sign += generateType(generator, func.return_type);
    sign += " ";
    sign += func.name;
    sign += "(";
    sign += generateFunctionArguments(generator, func.args);
    sign += ")";
    generator.pushSignFunction(sign + ";");
    result += sign;
    result += " ";
    result += generateBlock(generator, func.body);
    return result;
  }

  // phase/generator/generation/generate.ts
  function generate(generator) {
    if (generator.ast.layout) {
      generator.source += generateLayout(generator, generator.ast.layout);
    }
    for (const func of generator.ast.functions) {
      const func_str = generateFunctionDeclaration(generator, func);
      if (func_str.length > 0) {
        generator.pushFunction(func_str);
      }
    }
  }

  // common/cli/run/generator.ts
  function processCommandRunGenerator(fileName, absoluteDirPath, source, selectedLanguage) {
    let fs;
    if (typeof window === "undefined") {
      fs = import("fs");
    }
    const lexer = new Lexer(source, selectedLanguage, fileName, absoluteDirPath);
    lex(lexer);
    const parser = new Parser(lexer);
    parse(parser);
    if (typeof window !== "undefined") {
      window.lexer = lexer;
      window.parser = parser;
    }
    if (!checkError(parser, void 0, void 0)) {
      return 1;
    }
    const validator = new Validator(parser.ast);
    validate(validator);
    if (typeof window !== "undefined") {
      window.validator = validator;
    }
    if (!checkError(parser, validator, void 0)) {
      return 1;
    }
    if (typeof window === "undefined") {
      const astFileName = "test.json";
      if (fs.existsSync(astFileName)) {
        fs.unlinkSync(astFileName);
      }
      validator.writeToFile(astFileName);
    }
    const generator = new Generator(validator.ast, validator.extendedFunctions, validator.extendedVariables, validator.packages);
    generate(generator);
    if (typeof window !== "undefined") {
      window.generator = generator;
    }
    if (!checkError(parser, validator, generator)) {
      return 1;
    }
    if (typeof window === "undefined") {
      const outputFileName = "test.c";
      if (fs.existsSync(outputFileName)) {
        fs.unlinkSync(outputFileName);
      }
      generator.writeToFile(outputFileName);
    }
    return 0;
  }

  // common/cli/run/run.ts
  function processCommandRun(type, fileName, absoluteDirPath, source, selectedLanguage, languageCheck) {
    if (languageCheck === -1 && fileName !== void 0) {
      if (fileName.endsWith(".en.salam")) {
        selectedLanguage = languageMapsValues[0];
      } else if (fileName.endsWith(".fa.salam")) {
        selectedLanguage = languageMapsValues[1];
      }
    }
    switch (type) {
      case "lexer":
        return processCommandRunLexer(fileName, absoluteDirPath, source, selectedLanguage);
      case "parser":
        return processCommandRunParser(fileName, absoluteDirPath, source, selectedLanguage);
      case "validator":
        return processCommandRunValidator(fileName, absoluteDirPath, source, selectedLanguage);
      case "generator":
        return processCommandRunGenerator(fileName, absoluteDirPath, source, selectedLanguage);
      default: {
        console.error("Error: invalid type for running a script! '" + type + "'");
        return 1;
      }
    }
  }

  // common/cli/command/code.ts
  var code_flag = "code";
  function processCommandCode(type, args, selectedLanguage, languageCheck) {
    const source = args[args.indexOf(code_flag) + 1];
    if (!source) {
      console.error("Error: Code not provided.");
      return 1;
    }
    return processCommandRun(type, void 0, void 0, source, selectedLanguage, languageCheck);
  }

  // common/cli/command/file.ts
  function processCommandFile(type, args, selectedLanguage, languageCheck) {
    let fs;
    let path;
    if (typeof window === "undefined") {
      fs = import("fs");
      path = import("path");
    }
    if (!fs || !path) {
      return 1;
    }
    const filePath = args[args.indexOf("file") + 1] || void 0;
    let source, fileName, absoluteDirPath;
    try {
      if (!filePath) {
        console.error(`Error: File path not provided.`);
        return 1;
      } else if (!fs.existsSync(filePath)) {
        console.error(`Error: File not found - "${filePath}"`);
        return 1;
      }
      fileName = fs.realpathSync(filePath);
      absoluteDirPath = fs.realpathSync(path.dirname(filePath));
      source = fs.readFileSync(fileName, "utf8");
    } catch (error) {
      if (error instanceof Error) {
        if (error.code === "ENOENT") {
          console.error(`Error: File not found - "${filePath}"`);
        } else {
          console.error(`Error reading file: ${error.message}`);
        }
      } else {
        console.error(`Unknown error occurred.`);
      }
      return 1;
    }
    return processCommandRun(type, fileName, absoluteDirPath, source, selectedLanguage, languageCheck);
  }

  // common/cli/command/version.ts
  function processCommandVersion(type, args) {
    if (hasExtraArguments(args)) {
      return 1;
    }
    console.log("Salam CLI, version " + SALAM_VERSION);
    return 0;
  }

  // common/cli/cli.ts
  function processCommand(type, args, selectedLanguage, languageCheck) {
    const command = args.find((arg, index) => {
      const previousArg = args[index - 1];
      return !arg.startsWith("--") && previousArg !== lang_flag;
    });
    if (command === void 0) {
      console.error("Error: No command provided.");
      return handleMissingArguments(type);
    } else if (command === "version") {
      return processCommandVersion(type, args);
    } else if (command === "help") {
      return processCommandHelp(type, args);
    } else if (command === "file") {
      return processCommandFile(type, args, selectedLanguage, languageCheck);
    } else if (command === "code") {
      return processCommandCode(type, args, selectedLanguage, languageCheck);
    } else {
      console.error("Error: Invalid command.");
      showUsage(type);
      return 1;
    }
  }

  // main.ts
  var phases = [
    "lexer",
    "parser",
    "validator",
    "generator"
  ];
  var finalPhase = phases[phases.length - 1];
  function displayHelp() {
    console.log("You need to choose a phase of the Salam programming language:");
    phases.forEach((phase) => {
      console.log(`    ${phase}`);
    });
    console.log("");
  }
  function mainSalam(args) {
    if (args.length === 0) {
      displayHelp();
      return 1;
    }
    const selectedLanguage = languageMapsValues[0];
    const languageResult = processLanguageFlag(args, selectedLanguage);
    if (languageResult === 1) {
      return languageResult;
    }
    const selectedPhase = args[0];
    if (!phases.includes(selectedPhase)) {
      return processCommand(finalPhase, args, selectedLanguage, languageResult);
    }
    const remainingArgs = args.slice(1);
    return processCommand(selectedPhase, remainingArgs, selectedLanguage, languageResult);
  }
  if (typeof window === "undefined") {
    const args = process?.argv?.slice(2) || [];
    process.exit(mainSalam(args));
  } else {
    window.mainSalam = mainSalam;
  }
})();
